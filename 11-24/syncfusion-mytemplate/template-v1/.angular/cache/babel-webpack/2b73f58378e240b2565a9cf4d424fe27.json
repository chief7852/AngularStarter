{"ast":null,"code":"import _classCallCheck from \"D:/angularStarter/11-24/syncfusion-mytemplate/template-v1/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/angularStarter/11-24/syncfusion-mytemplate/template-v1/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Encoding, Save } from '@syncfusion/ej2-file-utils';\n/**\n * array literal codes\n */\n\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\n\nvar CompressedStreamWriter = /*#__PURE__*/function () {\n  /**\n   * Initializes compressor and writes ZLib header if needed.\n   * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n   */\n  function CompressedStreamWriter(noWrap) {\n    _classCallCheck(this, CompressedStreamWriter);\n\n    this.pendingBuffer = new Uint8Array(1 << 16);\n    this.pendingBufLength = 0;\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.currentHash = 0;\n    this.matchStart = 0;\n    this.matchLength = 0;\n    this.matchPrevAvail = false;\n    this.blockStart = 0;\n    this.stringStart = 0;\n    this.lookAhead = 0;\n    this.totalBytesIn = 0;\n    this.inputOffset = 0;\n    this.inputEnd = 0;\n    this.windowSize = 1 << 15;\n    this.windowMask = this.windowSize - 1;\n    this.hashSize = 1 << 15;\n    this.hashMask = this.hashSize - 1;\n    this.hashShift = Math.floor((15 + 3 - 1) / 3);\n    this.maxDist = this.windowSize - 262;\n    this.checkSum = 1;\n    this.noWrap = false;\n\n    if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n      CompressedStreamWriter.initHuffmanTree();\n      CompressedStreamWriter.isHuffmanTreeInitiated = true;\n    }\n\n    this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n    this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n    this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n    this.arrDistances = new Uint16Array(1 << 14);\n    this.arrLiterals = new Uint8Array(1 << 14);\n    this.stream = [];\n    this.dataWindow = new Uint8Array(2 * this.windowSize);\n    this.hashHead = new Int16Array(this.hashSize);\n    this.hashPrevious = new Int16Array(this.windowSize);\n    this.blockStart = this.stringStart = 1;\n    this.noWrap = noWrap;\n\n    if (!noWrap) {\n      this.writeZLibHeader();\n    }\n  }\n  /**\n   * get compressed data\n   */\n\n\n  _createClass(CompressedStreamWriter, [{\n    key: \"compressedData\",\n    get: function get() {\n      return this.stream;\n    }\n  }, {\n    key: \"getCompressedString\",\n    get: function get() {\n      var compressedString = '';\n\n      if (this.stream !== undefined) {\n        for (var i = 0; i < this.stream.length; i++) {\n          compressedString += String.fromCharCode.apply(null, this.stream[i]);\n        }\n      }\n\n      return compressedString;\n    }\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(data, offset, length) {\n      if (data === undefined || data === null) {\n        throw new Error('ArgumentException: data cannot null or undefined');\n      }\n\n      var end = offset + length;\n\n      if (0 > offset || offset > end || end > data.length) {\n        throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n      }\n\n      if (typeof data === 'string') {\n        var encode = new Encoding(false);\n        encode.type = 'Utf8';\n        data = new Uint8Array(encode.getBytes(data, 0, data.length));\n        end = offset + data.length;\n      }\n\n      this.inputBuffer = data;\n      this.inputOffset = offset;\n      this.inputEnd = end;\n\n      if (!this.noWrap) {\n        this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n      }\n\n      while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n        this.pendingBufferFlush();\n        this.compressData(false);\n      }\n    }\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n\n  }, {\n    key: \"writeZLibHeader\",\n    value: function writeZLibHeader() {\n      /* Initialize header.*/\n      var headerDate = 8 + (7 << 4) << 8;\n      /* Save compression level.*/\n\n      headerDate |= (5 >> 2 & 3) << 6;\n      /* Align header.*/\n\n      headerDate += 31 - headerDate % 31;\n      /* Write header to stream.*/\n\n      this.pendingBufferWriteShortBytes(headerDate);\n    }\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n\n  }, {\n    key: \"pendingBufferWriteShortBytes\",\n    value: function pendingBufferWriteShortBytes(s) {\n      this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n      this.pendingBuffer[this.pendingBufLength++] = s;\n    }\n  }, {\n    key: \"compressData\",\n    value: function compressData(finish) {\n      var success;\n\n      do {\n        this.fillWindow();\n        var canFlush = finish && this.inputEnd === this.inputOffset;\n        success = this.compressSlow(canFlush, finish);\n      } while (this.pendingBufLength === 0 && success);\n\n      return success;\n    }\n  }, {\n    key: \"compressSlow\",\n    value: function compressSlow(flush, finish) {\n      if (this.lookAhead < 262 && !flush) {\n        return false;\n      }\n\n      while (this.lookAhead >= 262 || flush) {\n        if (this.lookAhead === 0) {\n          return this.lookAheadCompleted(finish);\n        }\n\n        if (this.stringStart >= 2 * this.windowSize - 262) {\n          this.slideWindow();\n        }\n\n        var prevMatch = this.matchStart;\n        var prevLen = this.matchLength;\n\n        if (this.lookAhead >= 3) {\n          this.discardMatch();\n        }\n\n        if (prevLen >= 3 && this.matchLength <= prevLen) {\n          prevLen = this.matchPreviousBest(prevMatch, prevLen);\n        } else {\n          this.matchPreviousAvailable();\n        }\n\n        if (this.bufferPosition >= 1 << 14) {\n          return this.huffmanIsFull(finish);\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"discardMatch\",\n    value: function discardMatch() {\n      var hashHead = this.insertString();\n\n      if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n        if (this.matchLength <= 5 && this.matchLength === 3 && this.stringStart - this.matchStart > 4096) {\n          this.matchLength = 3 - 1;\n        }\n      }\n    }\n  }, {\n    key: \"matchPreviousAvailable\",\n    value: function matchPreviousAvailable() {\n      if (this.matchPrevAvail) {\n        this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n      }\n\n      this.matchPrevAvail = true;\n      this.stringStart++;\n      this.lookAhead--;\n    }\n  }, {\n    key: \"matchPreviousBest\",\n    value: function matchPreviousBest(prevMatch, prevLen) {\n      this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n      prevLen -= 2;\n\n      do {\n        this.stringStart++;\n        this.lookAhead--;\n\n        if (this.lookAhead >= 3) {\n          this.insertString();\n        }\n      } while (--prevLen > 0);\n\n      this.stringStart++;\n      this.lookAhead--;\n      this.matchPrevAvail = false;\n      this.matchLength = 3 - 1;\n      return prevLen;\n    }\n  }, {\n    key: \"lookAheadCompleted\",\n    value: function lookAheadCompleted(finish) {\n      if (this.matchPrevAvail) {\n        this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n      }\n\n      this.matchPrevAvail = false;\n      this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n      this.blockStart = this.stringStart;\n      return false;\n    }\n  }, {\n    key: \"huffmanIsFull\",\n    value: function huffmanIsFull(finish) {\n      var len = this.stringStart - this.blockStart;\n\n      if (this.matchPrevAvail) {\n        len--;\n      }\n\n      var lastBlock = finish && this.lookAhead === 0 && !this.matchPrevAvail;\n      this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n      this.blockStart += len;\n      return !lastBlock;\n    }\n  }, {\n    key: \"fillWindow\",\n    value: function fillWindow() {\n      if (this.stringStart >= this.windowSize + this.maxDist) {\n        this.slideWindow();\n      }\n\n      while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n        var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n\n        if (more > this.inputEnd - this.inputOffset) {\n          more = this.inputEnd - this.inputOffset;\n        }\n\n        this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n        this.inputOffset += more;\n        this.totalBytesIn += more;\n        this.lookAhead += more;\n      }\n\n      if (this.lookAhead >= 3) {\n        this.updateHash();\n      }\n    }\n  }, {\n    key: \"slideWindow\",\n    value: function slideWindow() {\n      this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n      this.matchStart -= this.windowSize;\n      this.stringStart -= this.windowSize;\n      this.blockStart -= this.windowSize;\n\n      for (var i = 0; i < this.hashSize; ++i) {\n        var m = this.hashHead[i] & 0xffff;\n        this.hashHead[i] = m >= this.windowSize ? m - this.windowSize : 0;\n      }\n\n      for (var _i = 0; _i < this.windowSize; _i++) {\n        var _m = this.hashPrevious[_i] & 0xffff;\n\n        this.hashPrevious[_i] = _m >= this.windowSize ? _m - this.windowSize : 0;\n      }\n    }\n  }, {\n    key: \"insertString\",\n    value: function insertString() {\n      var match;\n      var hash = (this.currentHash << this.hashShift ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n      this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n      this.hashHead[hash] = this.stringStart;\n      this.currentHash = hash;\n      return match & 0xffff;\n    }\n  }, {\n    key: \"findLongestMatch\",\n    value: function findLongestMatch(curMatch) {\n      var chainLen = 4096;\n      var niceLen = 258;\n      var scan = this.stringStart;\n      var match;\n      var bestEnd = this.stringStart + this.matchLength;\n      var bestLength = Math.max(this.matchLength, 3 - 1);\n      var limit = Math.max(this.stringStart - this.maxDist, 0);\n      var stringEnd = this.stringStart + 258 - 1;\n      var scanEnd1 = this.dataWindow[bestEnd - 1];\n      var scanEnd = this.dataWindow[bestEnd];\n      var data = this.dataWindow;\n\n      if (bestLength >= 32) {\n        chainLen >>= 2;\n      }\n\n      if (niceLen > this.lookAhead) {\n        niceLen = this.lookAhead;\n      }\n\n      do {\n        if (data[curMatch + bestLength] !== scanEnd || data[curMatch + bestLength - 1] !== scanEnd1 || data[curMatch] !== data[scan] || data[curMatch + 1] !== data[scan + 1]) {\n          continue;\n        }\n\n        match = curMatch + 2;\n        scan += 2;\n        /* tslint:disable */\n\n        while (data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n          /* tslint:disable */\n        }\n\n        if (scan > bestEnd) {\n          this.matchStart = curMatch;\n          bestEnd = scan;\n          bestLength = scan - this.stringStart;\n\n          if (bestLength >= niceLen) {\n            break;\n          }\n\n          scanEnd1 = data[bestEnd - 1];\n          scanEnd = data[bestEnd];\n        }\n\n        scan = this.stringStart;\n      } while ((curMatch = this.hashPrevious[curMatch & this.windowMask] & 0xffff) > limit && --chainLen !== 0);\n\n      this.matchLength = Math.min(bestLength, this.lookAhead);\n      return this.matchLength >= 3;\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash() {\n      this.currentHash = this.dataWindow[this.stringStart] << this.hashShift ^ this.dataWindow[this.stringStart + 1];\n    }\n  }, {\n    key: \"huffmanTallyLit\",\n    value: function huffmanTallyLit(literal) {\n      this.arrDistances[this.bufferPosition] = 0;\n      this.arrLiterals[this.bufferPosition++] = literal;\n      this.treeLiteral.codeFrequencies[literal]++;\n      return this.bufferPosition >= 1 << 14;\n    }\n  }, {\n    key: \"huffmanTallyDist\",\n    value: function huffmanTallyDist(dist, len) {\n      this.arrDistances[this.bufferPosition] = dist;\n      this.arrLiterals[this.bufferPosition++] = len - 3;\n      var lc = this.huffmanLengthCode(len - 3);\n      this.treeLiteral.codeFrequencies[lc]++;\n\n      if (lc >= 265 && lc < 285) {\n        this.extraBits += Math.floor((lc - 261) / 4);\n      }\n\n      var dc = this.huffmanDistanceCode(dist - 1);\n      this.treeDistances.codeFrequencies[dc]++;\n\n      if (dc >= 4) {\n        this.extraBits += Math.floor(dc / 2 - 1);\n      }\n\n      return this.bufferPosition >= 1 << 14;\n    }\n  }, {\n    key: \"huffmanFlushBlock\",\n    value: function huffmanFlushBlock(stored, storedOffset, storedLength, lastBlock) {\n      this.treeLiteral.codeFrequencies[256]++;\n      this.treeLiteral.buildTree();\n      this.treeDistances.buildTree();\n      this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n      this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n      this.treeCodeLengths.buildTree();\n      var blTreeCodes = 4;\n\n      for (var i = 18; i > blTreeCodes; i--) {\n        if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n          blTreeCodes = i + 1;\n        }\n      }\n\n      var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() + this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n      var static_len = this.extraBits;\n\n      for (var _i2 = 0; _i2 < 286; _i2++) {\n        static_len += this.treeLiteral.codeFrequencies[_i2] * ARR_LITERAL_LENGTHS[_i2];\n      }\n\n      for (var _i3 = 0; _i3 < 30; _i3++) {\n        static_len += this.treeDistances.codeFrequencies[_i3] * ARR_DISTANCE_LENGTHS[_i3];\n      }\n\n      if (opt_len >= static_len) {\n        // Force static trees.\n        opt_len = static_len;\n      }\n\n      if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n        this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n      } else if (opt_len == static_len) {\n        // Encode with static tree.\n        this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n        this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n        this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n        this.huffmanCompressBlock();\n        this.huffmanReset();\n      } else {\n        this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n        this.huffmanSendAllTrees(blTreeCodes);\n        this.huffmanCompressBlock();\n        this.huffmanReset();\n      }\n    }\n  }, {\n    key: \"huffmanFlushStoredBlock\",\n    value: function huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock) {\n      this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n      this.pendingBufferAlignToByte();\n      this.pendingBufferWriteShort(storedLength);\n      this.pendingBufferWriteShort(~storedLength);\n      this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n      this.huffmanReset();\n    }\n  }, {\n    key: \"huffmanLengthCode\",\n    value: function huffmanLengthCode(len) {\n      if (len === 255) {\n        return 285;\n      }\n\n      var code = 257;\n\n      while (len >= 8) {\n        code += 4;\n        len >>= 1;\n      }\n\n      return code + len;\n    }\n  }, {\n    key: \"huffmanDistanceCode\",\n    value: function huffmanDistanceCode(distance) {\n      var code = 0;\n\n      while (distance >= 4) {\n        code += 2;\n        distance >>= 1;\n      }\n\n      return code + distance;\n    }\n  }, {\n    key: \"huffmanSendAllTrees\",\n    value: function huffmanSendAllTrees(blTreeCodes) {\n      this.treeCodeLengths.buildCodes();\n      this.treeLiteral.buildCodes();\n      this.treeDistances.buildCodes();\n      this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n      this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n      this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n\n      for (var rank = 0; rank < blTreeCodes; rank++) {\n        this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n      }\n\n      this.treeLiteral.writeTree(this.treeCodeLengths);\n      this.treeDistances.writeTree(this.treeCodeLengths);\n    }\n  }, {\n    key: \"huffmanReset\",\n    value: function huffmanReset() {\n      this.bufferPosition = 0;\n      this.extraBits = 0;\n      this.treeLiteral.reset();\n      this.treeDistances.reset();\n      this.treeCodeLengths.reset();\n    }\n  }, {\n    key: \"huffmanCompressBlock\",\n    value: function huffmanCompressBlock() {\n      for (var i = 0; i < this.bufferPosition; i++) {\n        var literalLen = this.arrLiterals[i] & 255;\n        var dist = this.arrDistances[i];\n\n        if (dist-- !== 0) {\n          var lc = this.huffmanLengthCode(literalLen);\n          this.treeLiteral.writeCodeToStream(lc);\n          var bits = Math.floor((lc - 261) / 4);\n\n          if (bits > 0 && bits <= 5) {\n            this.pendingBufferWriteBits(literalLen & (1 << bits) - 1, bits);\n          }\n\n          var dc = this.huffmanDistanceCode(dist);\n          this.treeDistances.writeCodeToStream(dc);\n          bits = Math.floor(dc / 2 - 1);\n\n          if (bits > 0) {\n            this.pendingBufferWriteBits(dist & (1 << bits) - 1, bits);\n          }\n        } else {\n          this.treeLiteral.writeCodeToStream(literalLen);\n        }\n      }\n\n      this.treeLiteral.writeCodeToStream(256);\n    }\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n\n  }, {\n    key: \"pendingBufferWriteBits\",\n    value: function pendingBufferWriteBits(b, count) {\n      var uint = new Uint32Array(1);\n      uint[0] = this.pendingBufCache | b << this.pendingBufBitsInCache;\n      this.pendingBufCache = uint[0];\n      this.pendingBufBitsInCache += count;\n      this.pendingBufferFlushBits();\n    }\n  }, {\n    key: \"pendingBufferFlush\",\n    value: function pendingBufferFlush(isClose) {\n      this.pendingBufferFlushBits();\n\n      if (this.pendingBufLength > 0) {\n        var array = new Uint8Array(this.pendingBufLength);\n        array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n        this.stream.push(array);\n      }\n\n      this.pendingBufLength = 0;\n    }\n  }, {\n    key: \"pendingBufferFlushBits\",\n    value: function pendingBufferFlushBits() {\n      var result = 0;\n\n      while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < 1 << 16) {\n        this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        this.pendingBufCache >>= 8;\n        this.pendingBufBitsInCache -= 8;\n        result++;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"pendingBufferWriteByteBlock\",\n    value: function pendingBufferWriteByteBlock(data, offset, length) {\n      var array = data.subarray(offset, offset + length);\n      this.pendingBuffer.set(array, this.pendingBufLength);\n      this.pendingBufLength += length;\n    }\n  }, {\n    key: \"pendingBufferWriteShort\",\n    value: function pendingBufferWriteShort(s) {\n      this.pendingBuffer[this.pendingBufLength++] = s;\n      this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n    }\n  }, {\n    key: \"pendingBufferAlignToByte\",\n    value: function pendingBufferAlignToByte() {\n      if (this.pendingBufBitsInCache > 0) {\n        this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n      }\n\n      this.pendingBufCache = 0;\n      this.pendingBufBitsInCache = 0;\n    }\n    /**\n     * Huffman Tree literal calculation\n     * @private\n     */\n\n  }, {\n    key: \"close\",\n    value:\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n    function close() {\n      do {\n        this.pendingBufferFlush(true);\n\n        if (!this.compressData(true)) {\n          this.pendingBufferFlush(true);\n          this.pendingBufferAlignToByte();\n\n          if (!this.noWrap) {\n            this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n            this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n          }\n\n          this.pendingBufferFlush(true);\n        }\n      } while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0));\n    }\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.stream = [];\n      this.stream = undefined;\n      this.pendingBuffer = undefined;\n      this.treeLiteral = undefined;\n      this.treeDistances = undefined;\n      this.treeCodeLengths = undefined;\n      this.arrLiterals = undefined;\n      this.arrDistances = undefined;\n      this.hashHead = undefined;\n      this.hashPrevious = undefined;\n      this.dataWindow = undefined;\n      this.inputBuffer = undefined;\n      this.pendingBufLength = undefined;\n      this.pendingBufCache = undefined;\n      this.pendingBufBitsInCache = undefined;\n      this.bufferPosition = undefined;\n      this.extraBits = undefined;\n      this.currentHash = undefined;\n      this.matchStart = undefined;\n      this.matchLength = undefined;\n      this.matchPrevAvail = undefined;\n      this.blockStart = undefined;\n      this.stringStart = undefined;\n      this.lookAhead = undefined;\n      this.totalBytesIn = undefined;\n      this.inputOffset = undefined;\n      this.inputEnd = undefined;\n      this.windowSize = undefined;\n      this.windowMask = undefined;\n      this.hashSize = undefined;\n      this.hashMask = undefined;\n      this.hashShift = undefined;\n      this.maxDist = undefined;\n      this.checkSum = undefined;\n      this.noWrap = undefined;\n    }\n  }], [{\n    key: \"initHuffmanTree\",\n    value: function initHuffmanTree() {\n      var i = 0;\n\n      while (i < 144) {\n        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x030 + i << 8);\n        ARR_LITERAL_LENGTHS[i++] = 8;\n      }\n\n      while (i < 256) {\n        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x190 - 144 + i << 7);\n        ARR_LITERAL_LENGTHS[i++] = 9;\n      }\n\n      while (i < 280) {\n        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x000 - 256 + i << 9);\n        ARR_LITERAL_LENGTHS[i++] = 7;\n      }\n\n      while (i < 286) {\n        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x0c0 - 280 + i << 8);\n        ARR_LITERAL_LENGTHS[i++] = 8;\n      }\n\n      for (i = 0; i < 30; i++) {\n        ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n        ARR_DISTANCE_LENGTHS[i] = 5;\n      }\n    }\n  }]);\n\n  return CompressedStreamWriter;\n}();\n\nCompressedStreamWriter.isHuffmanTreeInitiated = false;\n/**\n * represent the Huffman Tree\n */\n\nvar CompressorHuffmanTree = /*#__PURE__*/function () {\n  /**\n   * Create new Huffman Tree\n   * @param {CompressedStreamWriter} writer instance\n   * @param {number} elementCount - element count\n   * @param {number} minCodes - minimum count\n   * @param {number} maxLength - maximum count\n   */\n  function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n    _classCallCheck(this, CompressorHuffmanTree);\n\n    this.writer = writer;\n    this.codeMinCount = minCodes;\n    this.maxLength = maxLength;\n    this.codeFrequency = new Uint16Array(elementCount);\n    this.lengthCount = new Int32Array(maxLength);\n  }\n\n  _createClass(CompressorHuffmanTree, [{\n    key: \"treeLength\",\n    get: function get() {\n      return this.codeCount;\n    }\n  }, {\n    key: \"codeLengths\",\n    get: function get() {\n      return this.codeLength;\n    }\n  }, {\n    key: \"codeFrequencies\",\n    get: function get() {\n      return this.codeFrequency;\n    }\n  }, {\n    key: \"setStaticCodes\",\n    value: function setStaticCodes(codes, lengths) {\n      var temp = new Int16Array(codes.length);\n      temp.set(codes, 0);\n      this.codes = temp;\n      var lengthTemp = new Uint8Array(lengths.length);\n      lengthTemp.set(lengths, 0);\n      this.codeLength = lengthTemp;\n    }\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      for (var i = 0; i < this.codeFrequency.length; i++) {\n        this.codeFrequency[i] = 0;\n      }\n\n      this.codes = undefined;\n      this.codeLength = undefined;\n    }\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n\n  }, {\n    key: \"writeCodeToStream\",\n    value: function writeCodeToStream(code) {\n      this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    }\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n\n  }, {\n    key: \"buildCodes\",\n    value: function buildCodes() {\n      var nextCode = new Int32Array(this.maxLength);\n      this.codes = new Int16Array(this.codeCount);\n      var code = 0;\n\n      for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n        nextCode[bitsCount] = code;\n        code += this.lengthCount[bitsCount] << 15 - bitsCount;\n      }\n\n      for (var i = 0; i < this.codeCount; i++) {\n        var bits = this.codeLength[i];\n\n        if (bits > 0) {\n          this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n          nextCode[bits - 1] += 1 << 16 - bits;\n        }\n      }\n    }\n  }, {\n    key: \"getEncodedLength\",\n    value:\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n    function getEncodedLength() {\n      var len = 0;\n\n      for (var i = 0; i < this.codeFrequency.length; i++) {\n        len += this.codeFrequency[i] * this.codeLength[i];\n      }\n\n      return len;\n    }\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n\n  }, {\n    key: \"calculateBLFreq\",\n    value: function calculateBLFreq(blTree) {\n      var maxCount;\n      var minCount;\n      var count;\n      var curLen = -1;\n      var i = 0;\n\n      while (i < this.codeCount) {\n        count = 1;\n        var nextLen = this.codeLength[i];\n\n        if (nextLen === 0) {\n          maxCount = 138;\n          minCount = 3;\n        } else {\n          maxCount = 6;\n          minCount = 3;\n\n          if (curLen !== nextLen) {\n            blTree.codeFrequency[nextLen]++;\n            count = 0;\n          }\n        }\n\n        curLen = nextLen;\n        i++;\n\n        while (i < this.codeCount && curLen === this.codeLength[i]) {\n          i++;\n\n          if (++count >= maxCount) {\n            break;\n          }\n        }\n\n        if (count < minCount) {\n          blTree.codeFrequency[curLen] += count;\n        } else if (curLen !== 0) {\n          blTree.codeFrequency[16]++;\n        } else if (count <= 10) {\n          blTree.codeFrequency[17]++;\n        } else {\n          blTree.codeFrequency[18]++;\n        }\n      }\n    }\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n\n  }, {\n    key: \"writeTree\",\n    value: function writeTree(blTree) {\n      var maxRepeatCount;\n      var minRepeatCount;\n      var currentRepeatCount;\n      var currentCodeLength = -1;\n      var i = 0;\n\n      while (i < this.codeCount) {\n        currentRepeatCount = 1;\n        var nextLen = this.codeLength[i];\n\n        if (nextLen === 0) {\n          maxRepeatCount = 138;\n          minRepeatCount = 3;\n        } else {\n          maxRepeatCount = 6;\n          minRepeatCount = 3;\n\n          if (currentCodeLength !== nextLen) {\n            blTree.writeCodeToStream(nextLen);\n            currentRepeatCount = 0;\n          }\n        }\n\n        currentCodeLength = nextLen;\n        i++;\n\n        while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n          i++;\n\n          if (++currentRepeatCount >= maxRepeatCount) {\n            break;\n          }\n        }\n\n        if (currentRepeatCount < minRepeatCount) {\n          while (currentRepeatCount-- > 0) {\n            blTree.writeCodeToStream(currentCodeLength);\n          }\n        } else if (currentCodeLength !== 0) {\n          blTree.writeCodeToStream(16);\n          this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n        } else if (currentRepeatCount <= 10) {\n          blTree.writeCodeToStream(17);\n          this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n        } else {\n          blTree.writeCodeToStream(18);\n          this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n        }\n      }\n    }\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n\n  }, {\n    key: \"buildTree\",\n    value: function buildTree() {\n      var codesCount = this.codeFrequency.length;\n      var arrTree = new Int32Array(codesCount);\n      var treeLength = 0;\n      var maxCount = 0;\n\n      for (var n = 0; n < codesCount; n++) {\n        var freq = this.codeFrequency[n];\n\n        if (freq !== 0) {\n          var pos = treeLength++;\n          var pPos = 0;\n\n          while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n            arrTree[pos] = arrTree[pPos];\n            pos = pPos;\n          }\n\n          arrTree[pos] = n;\n          maxCount = n;\n        }\n      }\n\n      while (treeLength < 2) {\n        arrTree[treeLength++] = maxCount < 2 ? ++maxCount : 0;\n      }\n\n      this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n      var leafsCount = treeLength;\n      var nodesCount = leafsCount;\n      var child = new Int32Array(4 * treeLength - 2);\n      var values = new Int32Array(2 * treeLength - 1);\n\n      for (var i = 0; i < treeLength; i++) {\n        var node = arrTree[i];\n        var iIndex = 2 * i;\n        child[iIndex] = node;\n        child[iIndex + 1] = -1;\n        values[i] = this.codeFrequency[node] << 8;\n        arrTree[i] = i;\n      }\n\n      this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n      this.buildLength(child);\n    }\n  }, {\n    key: \"constructHuffmanTree\",\n    value: function constructHuffmanTree(arrTree, treeLength, values, nodesCount, child) {\n      do {\n        var first = arrTree[0];\n        var last = arrTree[--treeLength];\n        var lastVal = values[last];\n        var pPos = 0;\n        var path = 1;\n\n        while (path < treeLength) {\n          if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n            path++;\n          }\n\n          arrTree[pPos] = arrTree[path];\n          pPos = path;\n          path = pPos * 2 + 1;\n        }\n\n        while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n          arrTree[path] = arrTree[pPos];\n        }\n\n        arrTree[path] = last;\n        var second = arrTree[0];\n        last = nodesCount++;\n        child[2 * last] = first;\n        child[2 * last + 1] = second;\n        var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n        values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n        pPos = 0;\n        path = 1;\n        /* tslint:disable */\n\n        while (path < treeLength) {\n          if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n            path++;\n          }\n\n          arrTree[pPos] = arrTree[path];\n          pPos = path;\n          path = pPos * 2 + 1;\n        }\n        /* tslint:disable */\n\n\n        while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n          arrTree[path] = arrTree[pPos];\n        }\n\n        arrTree[path] = last;\n      } while (treeLength > 1);\n    }\n  }, {\n    key: \"buildLength\",\n    value: function buildLength(child) {\n      this.codeLength = new Uint8Array(this.codeFrequency.length);\n      var numNodes = Math.floor(child.length / 2);\n      var numLeafs = Math.floor((numNodes + 1) / 2);\n      var overflow = 0;\n\n      for (var i = 0; i < this.maxLength; i++) {\n        this.lengthCount[i] = 0;\n      }\n\n      overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n\n      if (overflow === 0) {\n        return;\n      }\n\n      var iIncreasableLength = this.maxLength - 1;\n\n      do {\n        while (this.lengthCount[--iIncreasableLength] === 0) {\n          /* tslint:disable */\n        }\n\n        do {\n          this.lengthCount[iIncreasableLength]--;\n          this.lengthCount[++iIncreasableLength]++;\n          overflow -= 1 << this.maxLength - 1 - iIncreasableLength;\n        } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n      } while (overflow > 0);\n\n      this.recreateTree(child, overflow, numLeafs);\n    }\n  }, {\n    key: \"recreateTree\",\n    value: function recreateTree(child, overflow, numLeafs) {\n      this.lengthCount[this.maxLength - 1] += overflow;\n      this.lengthCount[this.maxLength - 2] -= overflow;\n      var nodePtr = 2 * numLeafs;\n\n      for (var bits = this.maxLength; bits !== 0; bits--) {\n        var n = this.lengthCount[bits - 1];\n\n        while (n > 0) {\n          var childPtr = 2 * child[nodePtr++];\n\n          if (child[childPtr + 1] === -1) {\n            this.codeLength[child[childPtr]] = bits;\n            n--;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"calculateOptimalCodeLength\",\n    value: function calculateOptimalCodeLength(child, overflow, numNodes) {\n      var lengths = new Int32Array(numNodes);\n      lengths[numNodes - 1] = 0;\n\n      for (var i = numNodes - 1; i >= 0; i--) {\n        var childIndex = 2 * i + 1;\n\n        if (child[childIndex] !== -1) {\n          var bitLength = lengths[i] + 1;\n\n          if (bitLength > this.maxLength) {\n            bitLength = this.maxLength;\n            overflow++;\n          }\n\n          lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n        } else {\n          var _bitLength = lengths[i];\n          this.lengthCount[_bitLength - 1]++;\n          this.codeLength[child[childIndex - 1]] = lengths[i];\n        }\n      }\n\n      return overflow;\n    }\n  }], [{\n    key: \"bitReverse\",\n    value: function bitReverse(value) {\n      return CompressorHuffmanTree.reverseBits[value & 15] << 12 | CompressorHuffmanTree.reverseBits[value >> 4 & 15] << 8 | CompressorHuffmanTree.reverseBits[value >> 8 & 15] << 4 | CompressorHuffmanTree.reverseBits[value >> 12];\n    }\n  }]);\n\n  return CompressorHuffmanTree;\n}();\n\nCompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\nCompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\n\nvar ChecksumCalculator = /*#__PURE__*/function () {\n  function ChecksumCalculator() {\n    _classCallCheck(this, ChecksumCalculator);\n  }\n\n  _createClass(ChecksumCalculator, null, [{\n    key: \"checksumUpdate\",\n    value:\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    function checksumUpdate(checksum, buffer, offset, length) {\n      var uint = new Uint32Array(1);\n      uint[0] = checksum;\n      var checksum_uint = uint[0];\n      var s1 = uint[0] = checksum_uint & 65535;\n      var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n\n      while (length > 0) {\n        var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n        length -= steps;\n\n        while (--steps >= 0) {\n          s1 = s1 + (uint[0] = buffer[offset++] & 255);\n          s2 = s2 + s1;\n        }\n\n        s1 %= ChecksumCalculator.checksumBase;\n        s2 %= ChecksumCalculator.checksumBase;\n      }\n\n      checksum_uint = s2 << ChecksumCalculator.checkSumBitOffset | s1;\n      return checksum_uint;\n    }\n  }]);\n\n  return ChecksumCalculator;\n}();\n\nChecksumCalculator.checkSumBitOffset = 16;\nChecksumCalculator.checksumBase = 65521;\nChecksumCalculator.checksumIterationCount = 3800;\nvar CRC32TABLE = [];\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\n\nvar ZipArchive = /*#__PURE__*/function () {\n  /**\n   * constructor for creating ZipArchive instance\n   */\n  function ZipArchive() {\n    _classCallCheck(this, ZipArchive);\n\n    if (CRC32TABLE.length === 0) {\n      ZipArchive.initCrc32Table();\n    }\n\n    this.files = [];\n    this.level = 'Normal';\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n  /**\n   * add new item to archive\n   * @param {ZipArchiveItem} item - item to be added\n   * @returns {void}\n   */\n\n\n  _createClass(ZipArchive, [{\n    key: \"compressionLevel\",\n    get:\n    /**\n     * gets compression level\n     */\n    function get() {\n      return this.level;\n    }\n    /**\n     * sets compression level\n     */\n    ,\n    set: function set(level) {\n      this.level = level;\n    }\n    /**\n     * gets items count\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      if (this.files === undefined) {\n        return 0;\n      }\n\n      return this.files.length;\n    }\n  }, {\n    key: \"addItem\",\n    value: function addItem(item) {\n      if (item === null || item === undefined) {\n        throw new Error('ArgumentException: item cannot be null or undefined');\n      }\n\n      for (var i = 0; i < this.files.length; i++) {\n        var file = this.files[i];\n\n        if (file instanceof ZipArchiveItem) {\n          if (file.name === item.name) {\n            throw new Error('item with same name already exist');\n          }\n        }\n      }\n\n      this.files.push(item);\n    }\n    /**\n     * add new directory to archive\n     * @param directoryName directoryName to be created\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addDirectory\",\n    value: function addDirectory(directoryName) {\n      if (directoryName === null || directoryName === undefined) {\n        throw new Error('ArgumentException: string cannot be null or undefined');\n      }\n\n      if (directoryName.length === 0) {\n        throw new Error('ArgumentException: string cannot be empty');\n      }\n\n      if (directoryName.slice(-1) !== '/') {\n        directoryName += '/';\n      }\n\n      if (this.files.indexOf(directoryName) !== -1) {\n        throw new Error('item with same name already exist');\n      }\n\n      this.files.push(directoryName);\n    }\n    /**\n     * gets item at specified index\n     * @param {number} index - item index\n     * @returns {ZipArchiveItem}\n     */\n\n  }, {\n    key: \"getItem\",\n    value: function getItem(index) {\n      if (index >= 0 && index < this.files.length) {\n        return this.files[index];\n      }\n\n      return undefined;\n    }\n    /**\n     * determines whether an element is in the collection\n     * @param {string | ZipArchiveItem} item - item to search\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(item) {\n      return this.files.indexOf(item) !== -1 ? true : false;\n    }\n    /**\n     * save archive with specified file name\n     * @param {string} fileName save archive with specified file name\n     * @returns {Promise<ZipArchive>}\n     */\n\n  }, {\n    key: \"save\",\n    value: function save(fileName) {\n      if (fileName === null || fileName === undefined || fileName.length === 0) {\n        throw new Error('ArgumentException: fileName cannot be null or undefined');\n      }\n\n      if (this.files.length === 0) {\n        throw new Error('InvalidOperation');\n      }\n\n      var zipArchive = this;\n      var promise;\n      return promise = new Promise(function (resolve, reject) {\n        zipArchive.saveInternal(fileName, false).then(function () {\n          resolve(zipArchive);\n        });\n      });\n    }\n    /**\n     * Save archive as blob\n     * @return {Promise<Blob>}\n     */\n\n  }, {\n    key: \"saveAsBlob\",\n    value: function saveAsBlob() {\n      var zipArchive = this;\n      var promise;\n      return promise = new Promise(function (resolve, reject) {\n        zipArchive.saveInternal('', true).then(function (blob) {\n          resolve(blob);\n        });\n      });\n    }\n  }, {\n    key: \"saveInternal\",\n    value: function saveInternal(fileName, skipFileSave) {\n      var _this = this;\n\n      var zipArchive = this;\n      var promise;\n      return promise = new Promise(function (resolve, reject) {\n        var zipData = [];\n        var dirLength = 0;\n\n        for (var i = 0; i < zipArchive.files.length; i++) {\n          var compressedObject = _this.getCompressedData(_this.files[i]);\n\n          compressedObject.then(function (data) {\n            dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n\n            if (zipData.length === zipArchive.files.length) {\n              var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n              resolve(blob);\n            }\n          });\n        }\n      });\n    }\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.files !== undefined && this.files.length > 0) {\n        for (var i = 0; i < this.files.length; i++) {\n          var file = this.files[i];\n\n          if (file instanceof ZipArchiveItem) {\n            file.destroy();\n          }\n\n          file = undefined;\n        }\n\n        this.files = [];\n      }\n\n      this.files = undefined;\n      this.level = undefined;\n    }\n  }, {\n    key: \"getCompressedData\",\n    value: function getCompressedData(item) {\n      var zipArchive = this;\n      var promise = new Promise(function (resolve, reject) {\n        if (item instanceof ZipArchiveItem) {\n          var reader = new FileReader();\n\n          reader.onload = function () {\n            var input = new Uint8Array(reader.result);\n            var data = {\n              fileName: item.name,\n              crc32Value: 0,\n              compressedData: [],\n              compressedSize: undefined,\n              uncompressedDataSize: input.length,\n              compressionType: undefined,\n              isDirectory: false\n            };\n\n            if (zipArchive.level === 'Normal') {\n              zipArchive.compressData(input, data, CRC32TABLE);\n              var length = 0;\n\n              for (var i = 0; i < data.compressedData.length; i++) {\n                length += data.compressedData[i].length;\n              }\n\n              data.compressedSize = length;\n              data.compressionType = '\\x08\\x00'; //Deflated = 8\n            } else {\n              data.compressedSize = input.length;\n              data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n              data.compressionType = '\\x00\\x00'; // Stored = 0\n\n              data.compressedData.push(input);\n            }\n\n            resolve(data);\n          };\n\n          reader.readAsArrayBuffer(item.data);\n        } else {\n          var data = {\n            fileName: item,\n            crc32Value: 0,\n            compressedData: '',\n            compressedSize: 0,\n            uncompressedDataSize: 0,\n            compressionType: '\\x00\\x00',\n            isDirectory: true\n          };\n          resolve(data);\n        }\n      });\n      return promise;\n    }\n  }, {\n    key: \"compressData\",\n    value: function compressData(input, data, crc32Table) {\n      var compressor = new CompressedStreamWriter(true);\n      var currentIndex = 0;\n      var nextIndex = 0;\n\n      do {\n        if (currentIndex >= input.length) {\n          compressor.close();\n          break;\n        }\n\n        nextIndex = Math.min(input.length, currentIndex + 16384);\n        var subArray = input.subarray(currentIndex, nextIndex);\n        data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n        compressor.write(subArray, 0, nextIndex - currentIndex);\n        currentIndex = nextIndex;\n      } while (currentIndex <= input.length);\n\n      data.compressedData = compressor.compressedData;\n      compressor.destroy();\n    }\n  }, {\n    key: \"constructZippedObject\",\n    value: function constructZippedObject(zipParts, data, dirLength, isDirectory) {\n      var extFileAttr = 0;\n      var date = new Date();\n\n      if (isDirectory) {\n        extFileAttr = extFileAttr | 0x00010; // directory flag\n      }\n\n      extFileAttr = extFileAttr | 0 & 0x3F;\n      var header = this.writeHeader(data, date);\n      var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n      var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n      zipParts.push({\n        localHeader: localHeader,\n        centralDir: centralDir,\n        compressedData: data\n      });\n      return dirLength + localHeader.length + data.compressedSize;\n    }\n  }, {\n    key: \"writeHeader\",\n    value: function writeHeader(data, date) {\n      var zipHeader = '';\n      zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n\n      zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n\n      zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n\n      zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n\n      zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n\n      zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n\n      zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n\n      zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n\n      zipHeader += this.getBytes(0, 2); // extra field length\n\n      return zipHeader;\n    }\n  }, {\n    key: \"writeZippedContent\",\n    value: function writeZippedContent(fileName, zipData, localDirLen, skipFileSave) {\n      var cenDirLen = 0;\n      var buffer = [];\n\n      for (var i = 0; i < zipData.length; i++) {\n        var item = zipData[i];\n        cenDirLen += item.centralDir.length;\n        buffer.push(this.getArrayBuffer(item.localHeader));\n\n        while (item.compressedData.compressedData.length) {\n          buffer.push(item.compressedData.compressedData.shift().buffer);\n        }\n      }\n\n      for (var _i4 = 0; _i4 < zipData.length; _i4++) {\n        buffer.push(this.getArrayBuffer(zipData[_i4].centralDir));\n      }\n\n      buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n      var blob = new Blob(buffer, {\n        type: 'application/zip'\n      });\n\n      if (!skipFileSave) {\n        Save.save(fileName, blob);\n      }\n\n      return blob;\n    }\n  }, {\n    key: \"writeCentralDirectory\",\n    value: function writeCentralDirectory(data, localHeader, offset, externalFileAttribute) {\n      var directoryHeader = 'PK\\x01\\x02' + this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n      this.getBytes(0, 2) + // comment length\n      '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n      this.getBytes(externalFileAttribute, 4) + // external file attributes\n      this.getBytes(offset, 4) + // local fileHeader relative offset\n      data.fileName;\n      return directoryHeader;\n    }\n  }, {\n    key: \"writeFooter\",\n    value: function writeFooter(zipData, centralLength, localLength) {\n      var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' + this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) + this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) + this.getBytes(0, 2);\n      return dirEnd;\n    }\n  }, {\n    key: \"getArrayBuffer\",\n    value: function getArrayBuffer(input) {\n      var a = new Uint8Array(input.length);\n\n      for (var j = 0; j < input.length; ++j) {\n        a[j] = input.charCodeAt(j) & 0xFF;\n      }\n\n      return a.buffer;\n    }\n  }, {\n    key: \"getBytes\",\n    value: function getBytes(value, offset) {\n      var bytes = '';\n\n      for (var i = 0; i < offset; i++) {\n        bytes += String.fromCharCode(value & 0xff);\n        value = value >>> 8;\n      }\n\n      return bytes;\n    }\n  }, {\n    key: \"getModifiedTime\",\n    value: function getModifiedTime(date) {\n      var modTime = date.getHours();\n      modTime = modTime << 6;\n      modTime = modTime | date.getMinutes();\n      modTime = modTime << 5;\n      return modTime = modTime | date.getSeconds() / 2;\n    }\n  }, {\n    key: \"getModifiedDate\",\n    value: function getModifiedDate(date) {\n      var modiDate = date.getFullYear() - 1980;\n      modiDate = modiDate << 4;\n      modiDate = modiDate | date.getMonth() + 1;\n      modiDate = modiDate << 5;\n      return modiDate = modiDate | date.getDate();\n    }\n  }, {\n    key: \"calculateCrc32Value\",\n    value: function calculateCrc32Value(crc32Value, input, crc32Table) {\n      crc32Value ^= -1;\n\n      for (var i = 0; i < input.length; i++) {\n        crc32Value = crc32Value >>> 8 ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n      }\n\n      return crc32Value ^ -1;\n    }\n    /**\n     * construct cyclic redundancy code table\n     * @private\n     */\n\n  }], [{\n    key: \"initCrc32Table\",\n    value: function initCrc32Table() {\n      var i;\n\n      for (var j = 0; j < 256; j++) {\n        i = j;\n\n        for (var k = 0; k < 8; k++) {\n          i = i & 1 ? 0xEDB88320 ^ i >>> 1 : i >>> 1;\n        }\n\n        CRC32TABLE[j] = i;\n      }\n    }\n  }]);\n\n  return ZipArchive;\n}();\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\n\n\nvar ZipArchiveItem = /*#__PURE__*/function () {\n  /**\n   * constructor for creating {ZipArchiveItem} instance\n   * @param {Blob|ArrayBuffer} data file data\n   * @param {itemName} itemName absolute file path\n   */\n  function ZipArchiveItem(data, itemName) {\n    _classCallCheck(this, ZipArchiveItem);\n\n    if (data === null || data === undefined) {\n      throw new Error('ArgumentException: data cannot be null or undefined');\n    }\n\n    if (itemName === null || itemName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (itemName.length === 0) {\n      throw new Error('string cannot be empty');\n    }\n\n    this.data = data;\n    this.name = itemName;\n  }\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  _createClass(ZipArchiveItem, [{\n    key: \"name\",\n    get:\n    /**\n     * Get the name of archive item\n     * @returns string\n     */\n    function get() {\n      return this.fileName;\n    }\n    /**\n     * Set the name of archive item\n     * @param  {string} value\n     */\n    ,\n    set: function set(value) {\n      this.fileName = value;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.fileName = undefined;\n      this.data = undefined;\n    }\n  }]);\n\n  return ZipArchiveItem;\n}();\n/**\n * export ZipArchive class\n */\n\n\nexport { ZipArchive, ZipArchiveItem, CompressedStreamWriter, CompressorHuffmanTree, ChecksumCalculator };","map":{"version":3,"sources":["D:/angularStarter/11-24/syncfusion-mytemplate/template-v1/node_modules/@syncfusion/ej2-compression/dist/es6/ej2-compression.es2015.js"],"names":["Encoding","Save","ARR_LITERAL_CODES","Int16Array","ARR_LITERAL_LENGTHS","Uint8Array","ARR_DISTANCE_CODES","ARR_DISTANCE_LENGTHS","CompressedStreamWriter","noWrap","pendingBuffer","pendingBufLength","pendingBufCache","pendingBufBitsInCache","bufferPosition","extraBits","currentHash","matchStart","matchLength","matchPrevAvail","blockStart","stringStart","lookAhead","totalBytesIn","inputOffset","inputEnd","windowSize","windowMask","hashSize","hashMask","hashShift","Math","floor","maxDist","checkSum","isHuffmanTreeInitiated","initHuffmanTree","treeLiteral","CompressorHuffmanTree","treeDistances","treeCodeLengths","arrDistances","Uint16Array","arrLiterals","stream","dataWindow","hashHead","hashPrevious","writeZLibHeader","compressedString","undefined","i","length","String","fromCharCode","apply","data","offset","Error","end","encode","type","getBytes","inputBuffer","ChecksumCalculator","checksumUpdate","pendingBufferFlush","compressData","headerDate","pendingBufferWriteShortBytes","s","finish","success","fillWindow","canFlush","compressSlow","flush","lookAheadCompleted","slideWindow","prevMatch","prevLen","discardMatch","matchPreviousBest","matchPreviousAvailable","huffmanIsFull","insertString","findLongestMatch","huffmanTallyLit","huffmanTallyDist","huffmanFlushBlock","len","lastBlock","more","set","subarray","updateHash","m","match","hash","curMatch","chainLen","niceLen","scan","bestEnd","bestLength","max","limit","stringEnd","scanEnd1","scanEnd","min","literal","codeFrequencies","dist","lc","huffmanLengthCode","dc","huffmanDistanceCode","stored","storedOffset","storedLength","buildTree","calculateBLFreq","blTreeCodes","codeLengths","huffCodeLengthOrders","opt_len","getEncodedLength","static_len","huffmanFlushStoredBlock","pendingBufferWriteBits","setStaticCodes","huffmanCompressBlock","huffmanReset","huffmanSendAllTrees","pendingBufferAlignToByte","pendingBufferWriteShort","pendingBufferWriteByteBlock","code","distance","buildCodes","treeLength","rank","writeTree","reset","literalLen","writeCodeToStream","bits","b","count","uint","Uint32Array","pendingBufferFlushBits","isClose","array","push","result","bitReverse","writer","elementCount","minCodes","maxLength","codeMinCount","codeFrequency","lengthCount","Int32Array","codeCount","codeLength","codes","lengths","temp","lengthTemp","nextCode","bitsCount","blTree","maxCount","minCount","curLen","nextLen","maxRepeatCount","minRepeatCount","currentRepeatCount","currentCodeLength","codesCount","arrTree","n","freq","pos","pPos","leafsCount","nodesCount","child","values","node","iIndex","constructHuffmanTree","buildLength","first","last","lastVal","path","second","minDepth","numNodes","numLeafs","overflow","calculateOptimalCodeLength","iIncreasableLength","recreateTree","nodePtr","childPtr","childIndex","bitLength","value","reverseBits","checksum","buffer","checksum_uint","s1","s2","checkSumBitOffset","steps","checksumIterationCount","checksumBase","CRC32TABLE","ZipArchive","initCrc32Table","files","level","isMicrosoftBrowser","navigator","msSaveBlob","item","file","ZipArchiveItem","name","directoryName","slice","indexOf","index","fileName","zipArchive","promise","Promise","resolve","reject","saveInternal","then","blob","skipFileSave","zipData","dirLength","compressedObject","getCompressedData","constructZippedObject","isDirectory","writeZippedContent","destroy","reader","FileReader","onload","input","crc32Value","compressedData","compressedSize","uncompressedDataSize","compressionType","calculateCrc32Value","readAsArrayBuffer","crc32Table","compressor","currentIndex","nextIndex","close","subArray","write","zipParts","extFileAttr","date","Date","header","writeHeader","localHeader","centralDir","writeCentralDirectory","zipHeader","getModifiedTime","getModifiedDate","localDirLen","cenDirLen","getArrayBuffer","shift","writeFooter","Blob","save","externalFileAttribute","directoryHeader","centralLength","localLength","dirEnd","a","j","charCodeAt","bytes","modTime","getHours","getMinutes","getSeconds","modiDate","getFullYear","getMonth","getDate","k","itemName"],"mappings":"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","sourcesContent":["import { Encoding, Save } from '@syncfusion/ej2-file-utils';\n\n/**\n * array literal codes\n */\nconst ARR_LITERAL_CODES = new Int16Array(286);\nconst ARR_LITERAL_LENGTHS = new Uint8Array(286);\nconst ARR_DISTANCE_CODES = new Int16Array(30);\nconst ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\nclass CompressedStreamWriter {\n    /**\n     * Initializes compressor and writes ZLib header if needed.\n     * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n     */\n    constructor(noWrap) {\n        this.pendingBuffer = new Uint8Array(1 << 16);\n        this.pendingBufLength = 0;\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.currentHash = 0;\n        this.matchStart = 0;\n        this.matchLength = 0;\n        this.matchPrevAvail = false;\n        this.blockStart = 0;\n        this.stringStart = 0;\n        this.lookAhead = 0;\n        this.totalBytesIn = 0;\n        this.inputOffset = 0;\n        this.inputEnd = 0;\n        this.windowSize = 1 << 15;\n        this.windowMask = this.windowSize - 1;\n        this.hashSize = 1 << 15;\n        this.hashMask = this.hashSize - 1;\n        this.hashShift = Math.floor((15 + 3 - 1) / 3);\n        this.maxDist = this.windowSize - 262;\n        this.checkSum = 1;\n        this.noWrap = false;\n        if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n            CompressedStreamWriter.initHuffmanTree();\n            CompressedStreamWriter.isHuffmanTreeInitiated = true;\n        }\n        this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n        this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n        this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n        this.arrDistances = new Uint16Array((1 << 14));\n        this.arrLiterals = new Uint8Array((1 << 14));\n        this.stream = [];\n        this.dataWindow = new Uint8Array(2 * this.windowSize);\n        this.hashHead = new Int16Array(this.hashSize);\n        this.hashPrevious = new Int16Array(this.windowSize);\n        this.blockStart = this.stringStart = 1;\n        this.noWrap = noWrap;\n        if (!noWrap) {\n            this.writeZLibHeader();\n        }\n    }\n    /**\n     * get compressed data\n     */\n    get compressedData() {\n        return this.stream;\n    }\n    get getCompressedString() {\n        let compressedString = '';\n        if (this.stream !== undefined) {\n            for (let i = 0; i < this.stream.length; i++) {\n                compressedString += String.fromCharCode.apply(null, this.stream[i]);\n            }\n        }\n        return compressedString;\n    }\n    /**\n     * Compresses data and writes it to the stream.\n     * @param {Uint8Array} data - data to compress\n     * @param {number} offset - offset in data\n     * @param {number} length - length of the data\n     * @returns {void}\n     */\n    write(data, offset, length) {\n        if (data === undefined || data === null) {\n            throw new Error('ArgumentException: data cannot null or undefined');\n        }\n        let end = offset + length;\n        if (0 > offset || offset > end || end > data.length) {\n            throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n        }\n        if (typeof data === 'string') {\n            let encode = new Encoding(false);\n            encode.type = 'Utf8';\n            data = new Uint8Array(encode.getBytes(data, 0, data.length));\n            end = offset + data.length;\n        }\n        this.inputBuffer = data;\n        this.inputOffset = offset;\n        this.inputEnd = end;\n        if (!this.noWrap) {\n            this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n        }\n        while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n            this.pendingBufferFlush();\n            this.compressData(false);\n        }\n    }\n    /**\n     * write ZLib header to the compressed data\n     * @return {void}\n     */\n    writeZLibHeader() {\n        /* Initialize header.*/\n        let headerDate = (8 + (7 << 4)) << 8;\n        /* Save compression level.*/\n        headerDate |= ((5 >> 2) & 3) << 6;\n        /* Align header.*/\n        headerDate += 31 - (headerDate % 31);\n        /* Write header to stream.*/\n        this.pendingBufferWriteShortBytes(headerDate);\n    }\n    /**\n     *  Write Most Significant Bytes in to stream\n     * @param {number} s - check sum value\n     */\n    pendingBufferWriteShortBytes(s) {\n        this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n        this.pendingBuffer[this.pendingBufLength++] = s;\n    }\n    compressData(finish) {\n        let success;\n        do {\n            this.fillWindow();\n            let canFlush = (finish && this.inputEnd === this.inputOffset);\n            success = this.compressSlow(canFlush, finish);\n        } while (this.pendingBufLength === 0 && success);\n        return success;\n    }\n    compressSlow(flush, finish) {\n        if (this.lookAhead < 262 && !flush) {\n            return false;\n        }\n        while (this.lookAhead >= 262 || flush) {\n            if (this.lookAhead === 0) {\n                return this.lookAheadCompleted(finish);\n            }\n            if (this.stringStart >= 2 * this.windowSize - 262) {\n                this.slideWindow();\n            }\n            let prevMatch = this.matchStart;\n            let prevLen = this.matchLength;\n            if (this.lookAhead >= 3) {\n                this.discardMatch();\n            }\n            if (prevLen >= 3 && this.matchLength <= prevLen) {\n                prevLen = this.matchPreviousBest(prevMatch, prevLen);\n            }\n            else {\n                this.matchPreviousAvailable();\n            }\n            if (this.bufferPosition >= (1 << 14)) {\n                return this.huffmanIsFull(finish);\n            }\n        }\n        return true;\n    }\n    discardMatch() {\n        let hashHead = this.insertString();\n        if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n            if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {\n                this.matchLength = 3 - 1;\n            }\n        }\n    }\n    matchPreviousAvailable() {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = true;\n        this.stringStart++;\n        this.lookAhead--;\n    }\n    matchPreviousBest(prevMatch, prevLen) {\n        this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n        prevLen -= 2;\n        do {\n            this.stringStart++;\n            this.lookAhead--;\n            if (this.lookAhead >= 3) {\n                this.insertString();\n            }\n        } while (--prevLen > 0);\n        this.stringStart++;\n        this.lookAhead--;\n        this.matchPrevAvail = false;\n        this.matchLength = 3 - 1;\n        return prevLen;\n    }\n    lookAheadCompleted(finish) {\n        if (this.matchPrevAvail) {\n            this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n        }\n        this.matchPrevAvail = false;\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n        this.blockStart = this.stringStart;\n        return false;\n    }\n    huffmanIsFull(finish) {\n        let len = this.stringStart - this.blockStart;\n        if (this.matchPrevAvail) {\n            len--;\n        }\n        let lastBlock = (finish && this.lookAhead === 0 && !this.matchPrevAvail);\n        this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n        this.blockStart += len;\n        return !lastBlock;\n    }\n    fillWindow() {\n        if (this.stringStart >= this.windowSize + this.maxDist) {\n            this.slideWindow();\n        }\n        while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n            let more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n            if (more > this.inputEnd - this.inputOffset) {\n                more = this.inputEnd - this.inputOffset;\n            }\n            this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n            this.inputOffset += more;\n            this.totalBytesIn += more;\n            this.lookAhead += more;\n        }\n        if (this.lookAhead >= 3) {\n            this.updateHash();\n        }\n    }\n    slideWindow() {\n        this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n        this.matchStart -= this.windowSize;\n        this.stringStart -= this.windowSize;\n        this.blockStart -= this.windowSize;\n        for (let i = 0; i < this.hashSize; ++i) {\n            let m = this.hashHead[i] & 0xffff;\n            this.hashHead[i] = (((m >= this.windowSize) ? (m - this.windowSize) : 0));\n        }\n        for (let i = 0; i < this.windowSize; i++) {\n            let m = this.hashPrevious[i] & 0xffff;\n            this.hashPrevious[i] = ((m >= this.windowSize) ? (m - this.windowSize) : 0);\n        }\n    }\n    insertString() {\n        let match;\n        let hash = ((this.currentHash << this.hashShift) ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n        this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n        this.hashHead[hash] = this.stringStart;\n        this.currentHash = hash;\n        return match & 0xffff;\n    }\n    findLongestMatch(curMatch) {\n        let chainLen = 4096;\n        let niceLen = 258;\n        let scan = this.stringStart;\n        let match;\n        let bestEnd = this.stringStart + this.matchLength;\n        let bestLength = Math.max(this.matchLength, 3 - 1);\n        let limit = Math.max(this.stringStart - this.maxDist, 0);\n        let stringEnd = this.stringStart + 258 - 1;\n        let scanEnd1 = this.dataWindow[bestEnd - 1];\n        let scanEnd = this.dataWindow[bestEnd];\n        let data = this.dataWindow;\n        if (bestLength >= 32) {\n            chainLen >>= 2;\n        }\n        if (niceLen > this.lookAhead) {\n            niceLen = this.lookAhead;\n        }\n        do {\n            if (data[curMatch + bestLength] !== scanEnd ||\n                data[curMatch + bestLength - 1] !== scanEnd1 ||\n                data[curMatch] !== data[scan] ||\n                data[curMatch + 1] !== data[scan + 1]) {\n                continue;\n            }\n            match = curMatch + 2;\n            scan += 2;\n            /* tslint:disable */\n            while (data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] &&\n                data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n                /* tslint:disable */\n            }\n            if (scan > bestEnd) {\n                this.matchStart = curMatch;\n                bestEnd = scan;\n                bestLength = scan - this.stringStart;\n                if (bestLength >= niceLen) {\n                    break;\n                }\n                scanEnd1 = data[bestEnd - 1];\n                scanEnd = data[bestEnd];\n            }\n            scan = this.stringStart;\n        } while ((curMatch = (this.hashPrevious[curMatch & this.windowMask] & 0xffff)) > limit && --chainLen !== 0);\n        this.matchLength = Math.min(bestLength, this.lookAhead);\n        return this.matchLength >= 3;\n    }\n    updateHash() {\n        this.currentHash = (this.dataWindow[this.stringStart] << this.hashShift) ^ this.dataWindow[this.stringStart + 1];\n    }\n    huffmanTallyLit(literal) {\n        this.arrDistances[this.bufferPosition] = 0;\n        this.arrLiterals[this.bufferPosition++] = literal;\n        this.treeLiteral.codeFrequencies[literal]++;\n        return this.bufferPosition >= (1 << 14);\n    }\n    huffmanTallyDist(dist, len) {\n        this.arrDistances[this.bufferPosition] = dist;\n        this.arrLiterals[this.bufferPosition++] = (len - 3);\n        let lc = this.huffmanLengthCode(len - 3);\n        this.treeLiteral.codeFrequencies[lc]++;\n        if (lc >= 265 && lc < 285) {\n            this.extraBits += Math.floor((lc - 261) / 4);\n        }\n        let dc = this.huffmanDistanceCode(dist - 1);\n        this.treeDistances.codeFrequencies[dc]++;\n        if (dc >= 4) {\n            this.extraBits += Math.floor((dc / 2 - 1));\n        }\n        return this.bufferPosition >= (1 << 14);\n    }\n    huffmanFlushBlock(stored, storedOffset, storedLength, lastBlock) {\n        this.treeLiteral.codeFrequencies[256]++;\n        this.treeLiteral.buildTree();\n        this.treeDistances.buildTree();\n        this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n        this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n        this.treeCodeLengths.buildTree();\n        let blTreeCodes = 4;\n        for (let i = 18; i > blTreeCodes; i--) {\n            if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n                blTreeCodes = i + 1;\n            }\n        }\n        let opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() +\n            this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n        let static_len = this.extraBits;\n        for (let i = 0; i < 286; i++) {\n            static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n        }\n        for (let i = 0; i < 30; i++) {\n            static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n        }\n        if (opt_len >= static_len) {\n            // Force static trees.\n            opt_len = static_len;\n        }\n        if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n            this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n        }\n        else if (opt_len == static_len) {\n            // Encode with static tree.\n            this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n            this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n            this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n        else {\n            this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n            this.huffmanSendAllTrees(blTreeCodes);\n            this.huffmanCompressBlock();\n            this.huffmanReset();\n        }\n    }\n    huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock) {\n        this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n        this.pendingBufferAlignToByte();\n        this.pendingBufferWriteShort(storedLength);\n        this.pendingBufferWriteShort(~storedLength);\n        this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n        this.huffmanReset();\n    }\n    huffmanLengthCode(len) {\n        if (len === 255) {\n            return 285;\n        }\n        let code = 257;\n        while (len >= 8) {\n            code += 4;\n            len >>= 1;\n        }\n        return code + len;\n    }\n    huffmanDistanceCode(distance) {\n        let code = 0;\n        while (distance >= 4) {\n            code += 2;\n            distance >>= 1;\n        }\n        return code + distance;\n    }\n    huffmanSendAllTrees(blTreeCodes) {\n        this.treeCodeLengths.buildCodes();\n        this.treeLiteral.buildCodes();\n        this.treeDistances.buildCodes();\n        this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n        this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n        this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n        for (let rank = 0; rank < blTreeCodes; rank++) {\n            this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n        }\n        this.treeLiteral.writeTree(this.treeCodeLengths);\n        this.treeDistances.writeTree(this.treeCodeLengths);\n    }\n    huffmanReset() {\n        this.bufferPosition = 0;\n        this.extraBits = 0;\n        this.treeLiteral.reset();\n        this.treeDistances.reset();\n        this.treeCodeLengths.reset();\n    }\n    huffmanCompressBlock() {\n        for (let i = 0; i < this.bufferPosition; i++) {\n            let literalLen = this.arrLiterals[i] & 255;\n            let dist = this.arrDistances[i];\n            if (dist-- !== 0) {\n                let lc = this.huffmanLengthCode(literalLen);\n                this.treeLiteral.writeCodeToStream(lc);\n                let bits = Math.floor((lc - 261) / 4);\n                if (bits > 0 && bits <= 5) {\n                    this.pendingBufferWriteBits(literalLen & ((1 << bits) - 1), bits);\n                }\n                let dc = this.huffmanDistanceCode(dist);\n                this.treeDistances.writeCodeToStream(dc);\n                bits = Math.floor(dc / 2 - 1);\n                if (bits > 0) {\n                    this.pendingBufferWriteBits(dist & ((1 << bits) - 1), bits);\n                }\n            }\n            else {\n                this.treeLiteral.writeCodeToStream(literalLen);\n            }\n        }\n        this.treeLiteral.writeCodeToStream(256);\n    }\n    /**\n     * write bits in to internal buffer\n     * @param {number} b - source of bits\n     * @param {number} count - count of bits to write\n     */\n    pendingBufferWriteBits(b, count) {\n        let uint = new Uint32Array(1);\n        uint[0] = this.pendingBufCache | (b << this.pendingBufBitsInCache);\n        this.pendingBufCache = uint[0];\n        this.pendingBufBitsInCache += count;\n        this.pendingBufferFlushBits();\n    }\n    pendingBufferFlush(isClose) {\n        this.pendingBufferFlushBits();\n        if (this.pendingBufLength > 0) {\n            let array = new Uint8Array(this.pendingBufLength);\n            array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n            this.stream.push(array);\n        }\n        this.pendingBufLength = 0;\n    }\n    pendingBufferFlushBits() {\n        let result = 0;\n        while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < (1 << 16)) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n            this.pendingBufCache >>= 8;\n            this.pendingBufBitsInCache -= 8;\n            result++;\n        }\n        return result;\n    }\n    pendingBufferWriteByteBlock(data, offset, length) {\n        let array = data.subarray(offset, offset + length);\n        this.pendingBuffer.set(array, this.pendingBufLength);\n        this.pendingBufLength += length;\n    }\n    pendingBufferWriteShort(s) {\n        this.pendingBuffer[this.pendingBufLength++] = s;\n        this.pendingBuffer[this.pendingBufLength++] = (s >> 8);\n    }\n    pendingBufferAlignToByte() {\n        if (this.pendingBufBitsInCache > 0) {\n            this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n        }\n        this.pendingBufCache = 0;\n        this.pendingBufBitsInCache = 0;\n    }\n    /**\n     * Huffman Tree literal calculation\n     * @private\n     */\n    static initHuffmanTree() {\n        let i = 0;\n        while (i < 144) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x030 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        while (i < 256) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x190 - 144 + i) << 7);\n            ARR_LITERAL_LENGTHS[i++] = 9;\n        }\n        while (i < 280) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x000 - 256 + i) << 9);\n            ARR_LITERAL_LENGTHS[i++] = 7;\n        }\n        while (i < 286) {\n            ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse((0x0c0 - 280 + i) << 8);\n            ARR_LITERAL_LENGTHS[i++] = 8;\n        }\n        for (i = 0; i < 30; i++) {\n            ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n            ARR_DISTANCE_LENGTHS[i] = 5;\n        }\n    }\n    /**\n     * close the stream and write all pending buffer in to stream\n     * @returns {void}\n     */\n    close() {\n        do {\n            this.pendingBufferFlush(true);\n            if (!this.compressData(true)) {\n                this.pendingBufferFlush(true);\n                this.pendingBufferAlignToByte();\n                if (!this.noWrap) {\n                    this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n                    this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n                }\n                this.pendingBufferFlush(true);\n            }\n        } while (!(this.inputEnd === this.inputOffset) ||\n            !(this.pendingBufLength === 0));\n    }\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    destroy() {\n        this.stream = [];\n        this.stream = undefined;\n        this.pendingBuffer = undefined;\n        this.treeLiteral = undefined;\n        this.treeDistances = undefined;\n        this.treeCodeLengths = undefined;\n        this.arrLiterals = undefined;\n        this.arrDistances = undefined;\n        this.hashHead = undefined;\n        this.hashPrevious = undefined;\n        this.dataWindow = undefined;\n        this.inputBuffer = undefined;\n        this.pendingBufLength = undefined;\n        this.pendingBufCache = undefined;\n        this.pendingBufBitsInCache = undefined;\n        this.bufferPosition = undefined;\n        this.extraBits = undefined;\n        this.currentHash = undefined;\n        this.matchStart = undefined;\n        this.matchLength = undefined;\n        this.matchPrevAvail = undefined;\n        this.blockStart = undefined;\n        this.stringStart = undefined;\n        this.lookAhead = undefined;\n        this.totalBytesIn = undefined;\n        this.inputOffset = undefined;\n        this.inputEnd = undefined;\n        this.windowSize = undefined;\n        this.windowMask = undefined;\n        this.hashSize = undefined;\n        this.hashMask = undefined;\n        this.hashShift = undefined;\n        this.maxDist = undefined;\n        this.checkSum = undefined;\n        this.noWrap = undefined;\n    }\n}\nCompressedStreamWriter.isHuffmanTreeInitiated = false;\n/**\n * represent the Huffman Tree\n */\nclass CompressorHuffmanTree {\n    /**\n     * Create new Huffman Tree\n     * @param {CompressedStreamWriter} writer instance\n     * @param {number} elementCount - element count\n     * @param {number} minCodes - minimum count\n     * @param {number} maxLength - maximum count\n     */\n    constructor(writer, elementCount, minCodes, maxLength) {\n        this.writer = writer;\n        this.codeMinCount = minCodes;\n        this.maxLength = maxLength;\n        this.codeFrequency = new Uint16Array(elementCount);\n        this.lengthCount = new Int32Array(maxLength);\n    }\n    get treeLength() {\n        return this.codeCount;\n    }\n    get codeLengths() {\n        return this.codeLength;\n    }\n    get codeFrequencies() {\n        return this.codeFrequency;\n    }\n    setStaticCodes(codes, lengths) {\n        let temp = new Int16Array(codes.length);\n        temp.set(codes, 0);\n        this.codes = temp;\n        let lengthTemp = new Uint8Array(lengths.length);\n        lengthTemp.set(lengths, 0);\n        this.codeLength = lengthTemp;\n    }\n    /**\n     * reset all code data in tree\n     * @returns {void}\n     */\n    reset() {\n        for (let i = 0; i < this.codeFrequency.length; i++) {\n            this.codeFrequency[i] = 0;\n        }\n        this.codes = undefined;\n        this.codeLength = undefined;\n    }\n    /**\n     * write code to the compressor output stream\n     * @param {number} code - code to be written\n     * @returns {void}\n     */\n    writeCodeToStream(code) {\n        this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n    }\n    /**\n     * calculate code from their frequencies\n     * @returns {void}\n     */\n    buildCodes() {\n        let nextCode = new Int32Array(this.maxLength);\n        this.codes = new Int16Array(this.codeCount);\n        let code = 0;\n        for (let bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n            nextCode[bitsCount] = code;\n            code += this.lengthCount[bitsCount] << (15 - bitsCount);\n        }\n        for (let i = 0; i < this.codeCount; i++) {\n            let bits = this.codeLength[i];\n            if (bits > 0) {\n                this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n                nextCode[bits - 1] += 1 << (16 - bits);\n            }\n        }\n    }\n    static bitReverse(value) {\n        return (CompressorHuffmanTree.reverseBits[value & 15] << 12\n            | CompressorHuffmanTree.reverseBits[(value >> 4) & 15] << 8\n            | CompressorHuffmanTree.reverseBits[(value >> 8) & 15] << 4\n            | CompressorHuffmanTree.reverseBits[value >> 12]);\n    }\n    /**\n     * calculate length of compressed data\n     * @returns {number}\n     */\n    getEncodedLength() {\n        let len = 0;\n        for (let i = 0; i < this.codeFrequency.length; i++) {\n            len += this.codeFrequency[i] * this.codeLength[i];\n        }\n        return len;\n    }\n    /**\n     * calculate code frequencies\n     * @param {CompressorHuffmanTree} blTree\n     * @returns {void}\n     */\n    calculateBLFreq(blTree) {\n        let maxCount;\n        let minCount;\n        let count;\n        let curLen = -1;\n        let i = 0;\n        while (i < this.codeCount) {\n            count = 1;\n            let nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxCount = 138;\n                minCount = 3;\n            }\n            else {\n                maxCount = 6;\n                minCount = 3;\n                if (curLen !== nextLen) {\n                    blTree.codeFrequency[nextLen]++;\n                    count = 0;\n                }\n            }\n            curLen = nextLen;\n            i++;\n            while (i < this.codeCount && curLen === this.codeLength[i]) {\n                i++;\n                if (++count >= maxCount) {\n                    break;\n                }\n            }\n            if (count < minCount) {\n                blTree.codeFrequency[curLen] += count;\n            }\n            else if (curLen !== 0) {\n                blTree.codeFrequency[16]++;\n            }\n            else if (count <= 10) {\n                blTree.codeFrequency[17]++;\n            }\n            else {\n                blTree.codeFrequency[18]++;\n            }\n        }\n    }\n    /**\n     * @param {CompressorHuffmanTree} blTree - write tree to output stream\n     * @returns {void}\n     */\n    writeTree(blTree) {\n        let maxRepeatCount;\n        let minRepeatCount;\n        let currentRepeatCount;\n        let currentCodeLength = -1;\n        let i = 0;\n        while (i < this.codeCount) {\n            currentRepeatCount = 1;\n            let nextLen = this.codeLength[i];\n            if (nextLen === 0) {\n                maxRepeatCount = 138;\n                minRepeatCount = 3;\n            }\n            else {\n                maxRepeatCount = 6;\n                minRepeatCount = 3;\n                if (currentCodeLength !== nextLen) {\n                    blTree.writeCodeToStream(nextLen);\n                    currentRepeatCount = 0;\n                }\n            }\n            currentCodeLength = nextLen;\n            i++;\n            while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n                i++;\n                if (++currentRepeatCount >= maxRepeatCount) {\n                    break;\n                }\n            }\n            if (currentRepeatCount < minRepeatCount) {\n                while (currentRepeatCount-- > 0) {\n                    blTree.writeCodeToStream(currentCodeLength);\n                }\n            }\n            else if (currentCodeLength !== 0) {\n                blTree.writeCodeToStream(16);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n            }\n            else if (currentRepeatCount <= 10) {\n                blTree.writeCodeToStream(17);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n            }\n            else {\n                blTree.writeCodeToStream(18);\n                this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n            }\n        }\n    }\n    /**\n     * Build huffman tree\n     * @returns {void}\n     */\n    buildTree() {\n        let codesCount = this.codeFrequency.length;\n        let arrTree = new Int32Array(codesCount);\n        let treeLength = 0;\n        let maxCount = 0;\n        for (let n = 0; n < codesCount; n++) {\n            let freq = this.codeFrequency[n];\n            if (freq !== 0) {\n                let pos = treeLength++;\n                let pPos = 0;\n                while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n                    arrTree[pos] = arrTree[pPos];\n                    pos = pPos;\n                }\n                arrTree[pos] = n;\n                maxCount = n;\n            }\n        }\n        while (treeLength < 2) {\n            arrTree[treeLength++] =\n                (maxCount < 2) ? ++maxCount : 0;\n        }\n        this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n        let leafsCount = treeLength;\n        let nodesCount = leafsCount;\n        let child = new Int32Array(4 * treeLength - 2);\n        let values = new Int32Array(2 * treeLength - 1);\n        for (let i = 0; i < treeLength; i++) {\n            let node = arrTree[i];\n            let iIndex = 2 * i;\n            child[iIndex] = node;\n            child[iIndex + 1] = -1;\n            values[i] = (this.codeFrequency[node] << 8);\n            arrTree[i] = i;\n        }\n        this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n        this.buildLength(child);\n    }\n    constructHuffmanTree(arrTree, treeLength, values, nodesCount, child) {\n        do {\n            let first = arrTree[0];\n            let last = arrTree[--treeLength];\n            let lastVal = values[last];\n            let pPos = 0;\n            let path = 1;\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            }\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n            let second = arrTree[0];\n            last = nodesCount++;\n            child[2 * last] = first;\n            child[2 * last + 1] = second;\n            let minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n            values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n            pPos = 0;\n            path = 1;\n            /* tslint:disable */\n            while (path < treeLength) {\n                if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n                    path++;\n                }\n                arrTree[pPos] = arrTree[path];\n                pPos = path;\n                path = pPos * 2 + 1;\n            } /* tslint:disable */\n            while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n                arrTree[path] = arrTree[pPos];\n            }\n            arrTree[path] = last;\n        } while (treeLength > 1);\n    }\n    buildLength(child) {\n        this.codeLength = new Uint8Array(this.codeFrequency.length);\n        let numNodes = Math.floor(child.length / 2);\n        let numLeafs = Math.floor((numNodes + 1) / 2);\n        let overflow = 0;\n        for (let i = 0; i < this.maxLength; i++) {\n            this.lengthCount[i] = 0;\n        }\n        overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n        if (overflow === 0) {\n            return;\n        }\n        let iIncreasableLength = this.maxLength - 1;\n        do {\n            while (this.lengthCount[--iIncreasableLength] === 0) {\n                /* tslint:disable */\n            }\n            do {\n                this.lengthCount[iIncreasableLength]--;\n                this.lengthCount[++iIncreasableLength]++;\n                overflow -= (1 << (this.maxLength - 1 - iIncreasableLength));\n            } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n        } while (overflow > 0);\n        this.recreateTree(child, overflow, numLeafs);\n    }\n    recreateTree(child, overflow, numLeafs) {\n        this.lengthCount[this.maxLength - 1] += overflow;\n        this.lengthCount[this.maxLength - 2] -= overflow;\n        let nodePtr = 2 * numLeafs;\n        for (let bits = this.maxLength; bits !== 0; bits--) {\n            let n = this.lengthCount[bits - 1];\n            while (n > 0) {\n                let childPtr = 2 * child[nodePtr++];\n                if (child[childPtr + 1] === -1) {\n                    this.codeLength[child[childPtr]] = bits;\n                    n--;\n                }\n            }\n        }\n    }\n    calculateOptimalCodeLength(child, overflow, numNodes) {\n        let lengths = new Int32Array(numNodes);\n        lengths[numNodes - 1] = 0;\n        for (let i = numNodes - 1; i >= 0; i--) {\n            let childIndex = 2 * i + 1;\n            if (child[childIndex] !== -1) {\n                let bitLength = lengths[i] + 1;\n                if (bitLength > this.maxLength) {\n                    bitLength = this.maxLength;\n                    overflow++;\n                }\n                lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n            }\n            else {\n                let bitLength = lengths[i];\n                this.lengthCount[bitLength - 1]++;\n                this.codeLength[child[childIndex - 1]] = lengths[i];\n            }\n        }\n        return overflow;\n    }\n}\nCompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\nCompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\nclass ChecksumCalculator {\n    /**\n     * Updates checksum by calculating checksum of the\n     * given buffer and adding it to current value.\n     * @param {number} checksum - current checksum.\n     * @param {Uint8Array} buffer - data byte array.\n     * @param {number} offset - offset in the buffer.\n     * @param {number} length - length of data to be used from the stream.\n     * @returns {number}\n     */\n    static checksumUpdate(checksum, buffer, offset, length) {\n        let uint = new Uint32Array(1);\n        uint[0] = checksum;\n        let checksum_uint = uint[0];\n        let s1 = uint[0] = checksum_uint & 65535;\n        let s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n        while (length > 0) {\n            let steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n            length -= steps;\n            while (--steps >= 0) {\n                s1 = s1 + (uint[0] = (buffer[offset++] & 255));\n                s2 = s2 + s1;\n            }\n            s1 %= ChecksumCalculator.checksumBase;\n            s2 %= ChecksumCalculator.checksumBase;\n        }\n        checksum_uint = (s2 << ChecksumCalculator.checkSumBitOffset) | s1;\n        return checksum_uint;\n    }\n}\nChecksumCalculator.checkSumBitOffset = 16;\nChecksumCalculator.checksumBase = 65521;\nChecksumCalculator.checksumIterationCount = 3800;\n\nconst CRC32TABLE = [];\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\nclass ZipArchive {\n    /**\n     * gets compression level\n     */\n    get compressionLevel() {\n        return this.level;\n    }\n    /**\n     * sets compression level\n     */\n    set compressionLevel(level) {\n        this.level = level;\n    }\n    /**\n     * gets items count\n     */\n    get length() {\n        if (this.files === undefined) {\n            return 0;\n        }\n        return this.files.length;\n    }\n    /**\n     * constructor for creating ZipArchive instance\n     */\n    constructor() {\n        if (CRC32TABLE.length === 0) {\n            ZipArchive.initCrc32Table();\n        }\n        this.files = [];\n        this.level = 'Normal';\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    /**\n     * add new item to archive\n     * @param {ZipArchiveItem} item - item to be added\n     * @returns {void}\n     */\n    addItem(item) {\n        if (item === null || item === undefined) {\n            throw new Error('ArgumentException: item cannot be null or undefined');\n        }\n        for (let i = 0; i < this.files.length; i++) {\n            let file = this.files[i];\n            if (file instanceof ZipArchiveItem) {\n                if (file.name === item.name) {\n                    throw new Error('item with same name already exist');\n                }\n            }\n        }\n        this.files.push(item);\n    }\n    /**\n     * add new directory to archive\n     * @param directoryName directoryName to be created\n     * @returns {void}\n     */\n    addDirectory(directoryName) {\n        if (directoryName === null || directoryName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (directoryName.length === 0) {\n            throw new Error('ArgumentException: string cannot be empty');\n        }\n        if (directoryName.slice(-1) !== '/') {\n            directoryName += '/';\n        }\n        if (this.files.indexOf(directoryName) !== -1) {\n            throw new Error('item with same name already exist');\n        }\n        this.files.push(directoryName);\n    }\n    /**\n     * gets item at specified index\n     * @param {number} index - item index\n     * @returns {ZipArchiveItem}\n     */\n    getItem(index) {\n        if (index >= 0 && index < this.files.length) {\n            return this.files[index];\n        }\n        return undefined;\n    }\n    /**\n     * determines whether an element is in the collection\n     * @param {string | ZipArchiveItem} item - item to search\n     * @returns {boolean}\n     */\n    contains(item) {\n        return this.files.indexOf(item) !== -1 ? true : false;\n    }\n    /**\n     * save archive with specified file name\n     * @param {string} fileName save archive with specified file name\n     * @returns {Promise<ZipArchive>}\n     */\n    save(fileName) {\n        if (fileName === null || fileName === undefined || fileName.length === 0) {\n            throw new Error('ArgumentException: fileName cannot be null or undefined');\n        }\n        if (this.files.length === 0) {\n            throw new Error('InvalidOperation');\n        }\n        let zipArchive = this;\n        let promise;\n        return promise = new Promise((resolve, reject) => {\n            zipArchive.saveInternal(fileName, false).then(() => {\n                resolve(zipArchive);\n            });\n        });\n    }\n    /**\n     * Save archive as blob\n     * @return {Promise<Blob>}\n     */\n    saveAsBlob() {\n        let zipArchive = this;\n        let promise;\n        return promise = new Promise((resolve, reject) => {\n            zipArchive.saveInternal('', true).then((blob) => {\n                resolve(blob);\n            });\n        });\n    }\n    saveInternal(fileName, skipFileSave) {\n        let zipArchive = this;\n        let promise;\n        return promise = new Promise((resolve, reject) => {\n            let zipData = [];\n            let dirLength = 0;\n            for (let i = 0; i < zipArchive.files.length; i++) {\n                let compressedObject = this.getCompressedData(this.files[i]);\n                compressedObject.then((data) => {\n                    dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n                    if (zipData.length === zipArchive.files.length) {\n                        let blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n                        resolve(blob);\n                    }\n                });\n            }\n        });\n    }\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    destroy() {\n        if (this.files !== undefined && this.files.length > 0) {\n            for (let i = 0; i < this.files.length; i++) {\n                let file = this.files[i];\n                if (file instanceof ZipArchiveItem) {\n                    file.destroy();\n                }\n                file = undefined;\n            }\n            this.files = [];\n        }\n        this.files = undefined;\n        this.level = undefined;\n    }\n    getCompressedData(item) {\n        let zipArchive = this;\n        let promise = new Promise((resolve, reject) => {\n            if (item instanceof ZipArchiveItem) {\n                let reader = new FileReader();\n                reader.onload = () => {\n                    let input = new Uint8Array(reader.result);\n                    let data = {\n                        fileName: item.name, crc32Value: 0, compressedData: [],\n                        compressedSize: undefined, uncompressedDataSize: input.length, compressionType: undefined,\n                        isDirectory: false\n                    };\n                    if (zipArchive.level === 'Normal') {\n                        zipArchive.compressData(input, data, CRC32TABLE);\n                        let length = 0;\n                        for (let i = 0; i < data.compressedData.length; i++) {\n                            length += data.compressedData[i].length;\n                        }\n                        data.compressedSize = length;\n                        data.compressionType = '\\x08\\x00'; //Deflated = 8\n                    }\n                    else {\n                        data.compressedSize = input.length;\n                        data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n                        data.compressionType = '\\x00\\x00'; // Stored = 0\n                        data.compressedData.push(input);\n                    }\n                    resolve(data);\n                };\n                reader.readAsArrayBuffer(item.data);\n            }\n            else {\n                let data = {\n                    fileName: item, crc32Value: 0, compressedData: '', compressedSize: 0, uncompressedDataSize: 0,\n                    compressionType: '\\x00\\x00', isDirectory: true\n                };\n                resolve(data);\n            }\n        });\n        return promise;\n    }\n    compressData(input, data, crc32Table) {\n        let compressor = new CompressedStreamWriter(true);\n        let currentIndex = 0;\n        let nextIndex = 0;\n        do {\n            if (currentIndex >= input.length) {\n                compressor.close();\n                break;\n            }\n            nextIndex = Math.min(input.length, currentIndex + 16384);\n            let subArray = input.subarray(currentIndex, nextIndex);\n            data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n            compressor.write(subArray, 0, nextIndex - currentIndex);\n            currentIndex = nextIndex;\n        } while (currentIndex <= input.length);\n        data.compressedData = compressor.compressedData;\n        compressor.destroy();\n    }\n    constructZippedObject(zipParts, data, dirLength, isDirectory) {\n        let extFileAttr = 0;\n        let date = new Date();\n        if (isDirectory) {\n            extFileAttr = extFileAttr | 0x00010; // directory flag\n        }\n        extFileAttr = extFileAttr | (0 & 0x3F);\n        let header = this.writeHeader(data, date);\n        let localHeader = 'PK\\x03\\x04' + header + data.fileName;\n        let centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n        zipParts.push({ localHeader: localHeader, centralDir: centralDir, compressedData: data });\n        return dirLength + localHeader.length + data.compressedSize;\n    }\n    writeHeader(data, date) {\n        let zipHeader = '';\n        zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n        zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n        zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n        zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n        zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n        zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n        zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n        zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n        zipHeader += this.getBytes(0, 2); // extra field length\n        return zipHeader;\n    }\n    writeZippedContent(fileName, zipData, localDirLen, skipFileSave) {\n        let cenDirLen = 0;\n        let buffer = [];\n        for (let i = 0; i < zipData.length; i++) {\n            let item = zipData[i];\n            cenDirLen += item.centralDir.length;\n            buffer.push(this.getArrayBuffer(item.localHeader));\n            while (item.compressedData.compressedData.length) {\n                buffer.push(item.compressedData.compressedData.shift().buffer);\n            }\n        }\n        for (let i = 0; i < zipData.length; i++) {\n            buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n        }\n        buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n        let blob = new Blob(buffer, { type: 'application/zip' });\n        if (!skipFileSave) {\n            Save.save(fileName, blob);\n        }\n        return blob;\n    }\n    writeCentralDirectory(data, localHeader, offset, externalFileAttribute) {\n        let directoryHeader = 'PK\\x01\\x02' +\n            this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n            this.getBytes(0, 2) + // comment length\n            '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n            this.getBytes(externalFileAttribute, 4) + // external file attributes\n            this.getBytes(offset, 4) + // local fileHeader relative offset\n            data.fileName;\n        return directoryHeader;\n    }\n    writeFooter(zipData, centralLength, localLength) {\n        let dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' +\n            this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) +\n            this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) +\n            this.getBytes(0, 2);\n        return dirEnd;\n    }\n    getArrayBuffer(input) {\n        let a = new Uint8Array(input.length);\n        for (let j = 0; j < input.length; ++j) {\n            a[j] = input.charCodeAt(j) & 0xFF;\n        }\n        return a.buffer;\n    }\n    getBytes(value, offset) {\n        let bytes = '';\n        for (let i = 0; i < offset; i++) {\n            bytes += String.fromCharCode(value & 0xff);\n            value = value >>> 8;\n        }\n        return bytes;\n    }\n    getModifiedTime(date) {\n        let modTime = date.getHours();\n        modTime = modTime << 6;\n        modTime = modTime | date.getMinutes();\n        modTime = modTime << 5;\n        return modTime = modTime | date.getSeconds() / 2;\n    }\n    getModifiedDate(date) {\n        let modiDate = date.getFullYear() - 1980;\n        modiDate = modiDate << 4;\n        modiDate = modiDate | (date.getMonth() + 1);\n        modiDate = modiDate << 5;\n        return modiDate = modiDate | date.getDate();\n    }\n    calculateCrc32Value(crc32Value, input, crc32Table) {\n        crc32Value ^= -1;\n        for (let i = 0; i < input.length; i++) {\n            crc32Value = (crc32Value >>> 8) ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n        }\n        return (crc32Value ^ (-1));\n    }\n    /**\n     * construct cyclic redundancy code table\n     * @private\n     */\n    static initCrc32Table() {\n        let i;\n        for (let j = 0; j < 256; j++) {\n            i = j;\n            for (let k = 0; k < 8; k++) {\n                i = ((i & 1) ? (0xEDB88320 ^ (i >>> 1)) : (i >>> 1));\n            }\n            CRC32TABLE[j] = i;\n        }\n    }\n}\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\nclass ZipArchiveItem {\n    /**\n     * Get the name of archive item\n     * @returns string\n     */\n    get name() {\n        return this.fileName;\n    }\n    /**\n     * Set the name of archive item\n     * @param  {string} value\n     */\n    set name(value) {\n        this.fileName = value;\n    }\n    /**\n     * constructor for creating {ZipArchiveItem} instance\n     * @param {Blob|ArrayBuffer} data file data\n     * @param {itemName} itemName absolute file path\n     */\n    constructor(data, itemName) {\n        if (data === null || data === undefined) {\n            throw new Error('ArgumentException: data cannot be null or undefined');\n        }\n        if (itemName === null || itemName === undefined) {\n            throw new Error('ArgumentException: string cannot be null or undefined');\n        }\n        if (itemName.length === 0) {\n            throw new Error('string cannot be empty');\n        }\n        this.data = data;\n        this.name = itemName;\n    }\n    /**\n     * release allocated un-managed resource\n     * @returns {void}\n     */\n    destroy() {\n        this.fileName = undefined;\n        this.data = undefined;\n    }\n}\n\n/**\n * export ZipArchive class\n */\n\nexport { ZipArchive, ZipArchiveItem, CompressedStreamWriter, CompressorHuffmanTree, ChecksumCalculator };\n"]},"metadata":{},"sourceType":"module"}