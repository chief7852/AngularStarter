{"ast":null,"code":"import _classCallCheck from \"D:/angularStarter/11-24/syncfusion-mytemplate/template-v1/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/angularStarter/11-24/syncfusion-mytemplate/template-v1/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * Save class provide method to save file\n * ```typescript\n * let blob : Blob = new Blob([''], { type: 'text/plain' });\n * Save.save('fileName.txt',blob);\n */\nvar Save = /*#__PURE__*/function () {\n  /**\n   * Initialize new instance of {save}\n   */\n  function Save() {// tslint:disable\n\n    _classCallCheck(this, Save);\n  }\n  /**\n   * Saves the file with specified name and sends the file to client browser\n   * @param  {string} fileName- file name to save.\n   * @param  {Blob} buffer- the content to write in file\n   * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not\n   * @returns {void}\n   */\n\n\n  _createClass(Save, null, [{\n    key: \"save\",\n    value: function save(fileName, buffer) {\n      if (fileName === null || fileName === undefined || fileName === '') {\n        throw new Error('ArgumentException: fileName cannot be undefined, null or empty');\n      }\n\n      var extension = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length);\n      var mimeType = this.getMimeType(extension);\n\n      if (mimeType !== '') {\n        buffer = new Blob([buffer], {\n          type: mimeType\n        });\n      }\n\n      if (this.isMicrosoftBrowser) {\n        navigator.msSaveBlob(buffer, fileName);\n      } else {\n        var downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n        this.saveInternal(fileName, extension, buffer, downloadLink, 'download' in downloadLink);\n      }\n    }\n  }, {\n    key: \"saveInternal\",\n    value: function saveInternal(fileName, extension, buffer, downloadLink, hasDownloadAttribute) {\n      if (hasDownloadAttribute) {\n        downloadLink.download = fileName;\n        var dataUrl = window.URL.createObjectURL(buffer);\n        downloadLink.href = dataUrl;\n        var event = document.createEvent('MouseEvent');\n        event.initEvent('click', true, true);\n        downloadLink.dispatchEvent(event);\n        setTimeout(function () {\n          window.URL.revokeObjectURL(dataUrl);\n          dataUrl = undefined;\n        });\n      } else {\n        if (extension !== 'docx' && extension !== 'xlsx') {\n          var url = window.URL.createObjectURL(buffer);\n          var isPopupBlocked = window.open(url, '_blank');\n\n          if (!isPopupBlocked) {\n            window.location.href = url;\n          }\n        } else {\n          var reader = new FileReader();\n\n          reader.onloadend = function () {\n            var isPopupBlocked = window.open(reader.result, '_blank');\n\n            if (!isPopupBlocked) {\n              window.location.href = reader.result;\n            }\n          };\n\n          reader.readAsDataURL(buffer);\n        }\n      }\n    }\n    /**\n     *\n     * @param {string} extension - get mime type of the specified extension\n     * @private\n     */\n\n  }, {\n    key: \"getMimeType\",\n    value: function getMimeType(extension) {\n      var mimeType = '';\n\n      switch (extension) {\n        case 'html':\n          mimeType = 'text/html';\n          break;\n\n        case 'pdf':\n          mimeType = 'application/pdf';\n          break;\n\n        case 'docx':\n          mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n          break;\n\n        case 'xlsx':\n          mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n          break;\n\n        case 'txt':\n          mimeType = 'text/plain';\n          break;\n      }\n\n      return mimeType;\n    }\n  }]);\n\n  return Save;\n}();\n/**\n * XmlWriter class provide method to create XML data\n */\n\n\nvar XmlWriter = /*#__PURE__*/function () {\n  /**\n   * Initialize new instance of {XmlWriter}\n   */\n  function XmlWriter() {\n    _classCallCheck(this, XmlWriter);\n\n    this.contentPos = 0;\n    this.bufferText = '';\n    this.bufferBlob = new Blob([''], {\n      type: 'text/plain'\n    });\n    this.currentState = 'Initial';\n    this.namespaceStack = [];\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[0].set('xmlns', 'http://www.w3.org/2000/xmlns/', 'Special');\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[1].set('xml', 'http://www.w3.org/XML/1998/namespace', 'Special');\n    this.namespaceStack.push(new Namespace());\n    this.namespaceStack[2].set('', '', 'Implied');\n    this.elementStack = [];\n    this.elementStack.push(new XmlElement());\n    this.elementStack[0].set('', '', '', this.namespaceStack.length - 1);\n    this.attributeStack = [];\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n  /**\n   * Gets the content written to the {XmlWriter} as Blob.\n   * @returns {Blob}\n   */\n\n\n  _createClass(XmlWriter, [{\n    key: \"buffer\",\n    get: function get() {\n      this.flush();\n      return this.bufferBlob;\n    }\n    /**\n     * Writes processing instruction with a space between the name and text\n     * @param {string} name - name of the processing instruction\n     * @param {string} text - text to write in the processing instruction\n     * @throws ArgumentException\n     * @throws InvalidArgumentException\n     * @throws InvalidOperationException\n     */\n\n  }, {\n    key: \"writeProcessingInstruction\",\n    value: function writeProcessingInstruction(name, text) {\n      if (name === undefined || name === null || name.length === 0) {\n        throw new Error('ArgumentException: name should not be undefined, null or empty');\n      }\n\n      this.checkName(name);\n\n      if (text === undefined || text === null) {\n        text = '';\n      }\n\n      if (name.length === 3 && name === 'xml') {\n        if (this.currentState !== 'Initial') {\n          // tslint:disable-next-line:max-line-length\n          throw new Error('InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it');\n        }\n      }\n\n      if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n        throw new Error('InvalidOperationException: Wrong Token');\n      } else {\n        this.writeStartDocument();\n        this.writeProcessingInstructionInternal(name, text);\n      }\n    }\n    /**\n     * Writes Xml declaration with version and standalone attribute\n     * @param {boolean} standalone - if true it write standalone=yes else standalone=no\n     * @throws InvalidOperation\n     */\n\n  }, {\n    key: \"writeStartDocument\",\n    value: function writeStartDocument(standalone) {\n      if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n        throw new Error('InvalidOperationException: Wrong Token');\n      }\n\n      this.currentState = 'StartDocument';\n      this.rawText('<?xml version=\"1.0\" encoding=\"utf-8');\n\n      if (standalone !== null && standalone !== undefined) {\n        this.rawText('\" standalone=\"');\n        this.rawText(standalone ? 'yes' : 'no');\n      }\n\n      this.rawText('\"?>');\n    }\n    /**\n     * Closes any open tag or attribute and write the state back to start\n     */\n\n  }, {\n    key: \"writeEndDocument\",\n    value: function writeEndDocument() {\n      while (this.elementStack.length - 1 > 0) {\n        this.writeEndElement();\n      }\n\n      this.currentState = 'EndDocument';\n      this.flush();\n    }\n    /**\n     * Writes the specified start tag and associates it with the given namespace and prefix.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName -localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @throws ArgumentException\n     * @throws InvalidOperationException\n     */\n\n  }, {\n    key: \"writeStartElement\",\n    value: function writeStartElement(prefix, localName, namespace) {\n      if (this.bufferBlob === undefined) {\n        throw new Error('InvalidOperationException: Wrong Token');\n      }\n\n      if (localName === undefined || localName === null || localName.length === 0) {\n        throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n      }\n\n      this.checkName(localName);\n\n      if (this.currentState === 'Initial') {\n        this.writeStartDocument();\n      }\n\n      if (this.currentState === 'StartElement') {\n        this.startElementContent();\n      }\n\n      this.currentState = 'StartElement';\n\n      if (prefix === undefined || prefix === null) {\n        if (namespace !== undefined && namespace !== null) {\n          prefix = this.lookupPrefix(namespace);\n        }\n\n        if (prefix === undefined || prefix === null) {\n          prefix = '';\n        }\n      } else if (prefix.length > 0) {\n        if (namespace === undefined || namespace === null) {\n          namespace = this.lookupNamespace(prefix);\n        }\n\n        if (namespace === undefined || namespace === null || namespace !== undefined && namespace.length === 0) {\n          throw new Error('ArgumentException: Cannot use a prefix with an empty namespace');\n        }\n      }\n\n      if (namespace === undefined || namespace === null) {\n        namespace = this.lookupNamespace(prefix);\n      }\n\n      this.writeStartElementInternal(prefix, localName, namespace);\n    }\n    /**\n     * Closes one element and pop corresponding namespace scope\n     */\n\n  }, {\n    key: \"writeEndElement\",\n    value: function writeEndElement() {\n      if (this.currentState === 'StartElement') {\n        this.startElementContent();\n        this.currentState = 'ElementContent';\n      } else if (this.currentState === 'ElementContent') {\n        this.currentState = 'ElementContent';\n      }\n\n      this.currentState = 'EndElement';\n      var top = this.elementStack.length - 1;\n      this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);\n      this.namespaceStack.splice(this.elementStack[top].previousTop + 1);\n      this.elementStack.splice(top);\n\n      if (this.bufferText.length > 10240) {\n        this.flush();\n      }\n    }\n    /**\n     * Writes an element with the specified prefix, local name, namespace URI, and value.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n\n  }, {\n    key: \"writeElementString\",\n    value: function writeElementString(prefix, localName, namespace, value) {\n      this.writeStartElement(prefix, localName, namespace);\n\n      if (value !== undefined && value !== null && value.length !== 0) {\n        this.writeString(value);\n      }\n\n      this.writeEndElement();\n    }\n    /**\n     * Writes out the attribute with the specified prefix, local name, namespace URI, and value\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n\n  }, {\n    key: \"writeAttributeString\",\n    value: function writeAttributeString(prefix, localName, namespace, value) {\n      this.writeStartAttribute(prefix, localName, namespace, value);\n      this.writeStringInternal(value, true);\n      this.writeEndAttribute();\n    }\n    /**\n     * Writes the given text content\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n\n  }, {\n    key: \"writeString\",\n    value: function writeString(text) {\n      this.writeInternal(text, false);\n    }\n    /**\n     * Write given text as raw data\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n\n  }, {\n    key: \"writeRaw\",\n    value: function writeRaw(text) {\n      this.writeInternal(text, true);\n    }\n  }, {\n    key: \"writeInternal\",\n    value: function writeInternal(text, isRawString) {\n      if (text === undefined || text === null) {\n        return;\n      } else {\n        if (this.currentState !== 'StartElement' && this.currentState !== 'ElementContent') {\n          throw new Error('InvalidOperationException: Wrong Token');\n        }\n\n        if (this.currentState === 'StartElement') {\n          this.startElementContent();\n        }\n\n        this.currentState = 'ElementContent';\n\n        if (isRawString) {\n          this.rawText(text);\n        } else {\n          this.writeStringInternal(text, false);\n        }\n      }\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param {string} fileName - file name\n     */\n\n  }, {\n    key: \"save\",\n    value: function save(fileName) {\n      while (this.elementStack.length - 1 > 0) {\n        this.writeEndElement();\n      }\n\n      if (this.bufferText !== '') {\n        this.flush();\n      }\n\n      Save.save(fileName, this.buffer);\n    }\n    /**\n     * Releases the resources used by XmlWriter.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.bufferBlob = undefined;\n\n      for (var i = 0; i < this.namespaceStack.length; i++) {\n        this.namespaceStack[i].destroy();\n      }\n\n      this.namespaceStack = [];\n\n      for (var _i = 0; _i < this.elementStack.length; _i++) {\n        this.elementStack[_i].destroy();\n      }\n\n      this.elementStack = [];\n      this.bufferText = '';\n      this.contentPos = 0;\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this.bufferBlob === undefined) {\n        return;\n      }\n\n      this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], {\n        type: 'text/plain'\n      });\n      this.bufferText = '';\n    }\n  }, {\n    key: \"writeProcessingInstructionInternal\",\n    value: function writeProcessingInstructionInternal(name, text) {\n      this.bufferText += '<?';\n      this.rawText(name);\n\n      if (text.length > 0) {\n        this.bufferText += ' ';\n        text = text.replace(/\\?\\>/g, '? >');\n        this.bufferText += text;\n      }\n\n      this.bufferText += '?';\n      this.bufferText += '>';\n    }\n  }, {\n    key: \"writeStartAttribute\",\n    value: function writeStartAttribute(prefix, localName, namespace, value) {\n      if (localName === undefined || localName === null || localName.length === 0) {\n        if (prefix === 'xmlns') {\n          localName = 'xmlns';\n          prefix = '';\n        } else {\n          throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n        }\n      }\n\n      if (this.currentState !== 'StartElement') {\n        throw new Error('InvalidOperationException: Wrong Token');\n      }\n\n      this.checkName(localName);\n      this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);\n    }\n  }, {\n    key: \"writeStartAttributePrefixAndNameSpace\",\n    value: function writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value) {\n      if (prefix === undefined || prefix === null) {\n        if (namespace !== undefined && namespace !== null) {\n          if (!(localName === 'xmlns' && namespace === 'http://www.w3.org/2000/xmlns/')) {\n            prefix = this.lookupPrefix(namespace);\n          }\n        }\n\n        if (prefix === undefined || prefix === null) {\n          prefix = '';\n        }\n      }\n\n      if (namespace === undefined || namespace === null) {\n        if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n          namespace = this.lookupNamespace(prefix);\n        }\n\n        if (namespace === undefined || namespace === null) {\n          namespace = '';\n        }\n      }\n\n      this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);\n    }\n  }, {\n    key: \"writeStartAttributeSpecialAttribute\",\n    value: function writeStartAttributeSpecialAttribute(prefix, localName, namespace, value) {\n      if (prefix.length === 0) {\n        if (localName[0] === 'x' && localName === 'xmlns') {\n          this.skipPushAndWrite(prefix, localName, namespace);\n          this.pushNamespaceExplicit('', value);\n          return;\n        } else if (namespace.length > 0) {\n          prefix = this.lookupPrefix(namespace);\n        }\n      } else {\n        if (prefix[0] === 'x') {\n          if (prefix === 'xmlns') {\n            this.skipPushAndWrite(prefix, localName, namespace);\n            this.pushNamespaceExplicit(localName, value);\n            return;\n          } else if (prefix === 'xml') {\n            if (localName === 'space' || localName === 'lang') {\n              this.skipPushAndWrite(prefix, localName, namespace);\n              return;\n            }\n          }\n        }\n\n        if (namespace.length === 0) {\n          prefix = '';\n        }\n      }\n\n      if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n        this.pushNamespaceImplicit(prefix, namespace);\n      }\n\n      this.skipPushAndWrite(prefix, localName, namespace);\n    }\n  }, {\n    key: \"writeEndAttribute\",\n    value: function writeEndAttribute() {\n      this.currentState = 'StartElement';\n      this.bufferText += '\"';\n    }\n  }, {\n    key: \"writeStartElementInternal\",\n    value: function writeStartElementInternal(prefix, localName, namespace) {\n      this.bufferText += '<';\n\n      if (prefix.length > 0) {\n        this.rawText(prefix);\n        this.bufferText += ':';\n      }\n\n      this.rawText(localName);\n      var top = this.elementStack.length;\n      this.elementStack.push(new XmlElement());\n      this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);\n      this.pushNamespaceImplicit(prefix, namespace);\n\n      for (var i = 0; i < this.attributeStack.length; i++) {\n        this.attributeStack[i].destroy();\n      }\n\n      this.attributeStack = [];\n    }\n  }, {\n    key: \"writeEndElementInternal\",\n    value: function writeEndElementInternal(prefix, localName) {\n      if (this.contentPos !== this.bufferText.length + 1) {\n        this.bufferText += '</';\n\n        if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n          this.rawText(prefix);\n          this.bufferText += ':';\n        }\n\n        this.rawText(localName);\n        this.bufferText += '>';\n      } else {\n        this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);\n        this.bufferText += ' />';\n      }\n    }\n  }, {\n    key: \"writeStartAttributeInternal\",\n    value: function writeStartAttributeInternal(prefix, localName, namespaceName) {\n      this.bufferText += ' ';\n\n      if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n        this.rawText(prefix);\n        this.bufferText += ':';\n      }\n\n      this.rawText(localName);\n      this.bufferText += '=';\n      this.bufferText += '\"';\n    }\n  }, {\n    key: \"writeNamespaceDeclaration\",\n    value: function writeNamespaceDeclaration(prefix, namespaceUri) {\n      this.writeStartNamespaceDeclaration(prefix);\n      this.writeStringInternal(namespaceUri, true);\n      this.bufferText += '\"';\n    }\n  }, {\n    key: \"writeStartNamespaceDeclaration\",\n    value: function writeStartNamespaceDeclaration(prefix) {\n      if (prefix === undefined || prefix === null || prefix.length === 0) {\n        this.rawText(' xmlns=\\\"');\n      } else {\n        this.rawText(' xmlns:');\n        this.rawText(prefix);\n        this.bufferText += '=';\n        this.bufferText += '\"';\n      }\n    }\n  }, {\n    key: \"writeStringInternal\",\n    value: function writeStringInternal(text, inAttributeValue) {\n      if (text === null || text === undefined) {\n        text = '';\n      }\n\n      text = text.replace(/\\&/g, '&amp;');\n      text = text.replace(/\\</g, '&lt;');\n      text = text.replace(/\\>/g, '&gt;');\n\n      if (inAttributeValue) {\n        text = text.replace(/\\\"/g, '&quot;');\n      }\n\n      this.bufferText += text;\n\n      if (!inAttributeValue) {\n        this.contentPos = 0;\n      }\n    }\n  }, {\n    key: \"startElementContent\",\n    value: function startElementContent() {\n      var start = this.elementStack[this.elementStack.length - 1].previousTop;\n\n      for (var i = this.namespaceStack.length - 1; i > start; i--) {\n        if (this.namespaceStack[i].kind === 'NeedToWrite') {\n          this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);\n        }\n      }\n\n      this.bufferText += '>';\n      this.contentPos = this.bufferText.length + 1;\n    }\n  }, {\n    key: \"rawText\",\n    value: function rawText(text) {\n      this.bufferText += text;\n    }\n  }, {\n    key: \"addNamespace\",\n    value: function addNamespace(prefix, ns, kind) {\n      var top = this.namespaceStack.length;\n      this.namespaceStack.push(new Namespace());\n      this.namespaceStack[top].set(prefix, ns, kind);\n    }\n  }, {\n    key: \"lookupPrefix\",\n    value: function lookupPrefix(namespace) {\n      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n        if (this.namespaceStack[i].namespaceUri === namespace) {\n          return this.namespaceStack[i].prefix;\n        }\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"lookupNamespace\",\n    value: function lookupNamespace(prefix) {\n      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n        if (this.namespaceStack[i].prefix === prefix) {\n          return this.namespaceStack[i].namespaceUri;\n        }\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"lookupNamespaceIndex\",\n    value: function lookupNamespaceIndex(prefix) {\n      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {\n        if (this.namespaceStack[i].prefix === prefix) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"pushNamespaceImplicit\",\n    value: function pushNamespaceImplicit(prefix, ns) {\n      var kind;\n      var existingNsIndex = this.lookupNamespaceIndex(prefix);\n\n      if (existingNsIndex !== -1) {\n        if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n          if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {\n            throw new Error('XmlException namespace Uri needs to be the same as the one that is already declared');\n          }\n\n          return;\n        } else {\n          if (this.namespaceStack[existingNsIndex].kind === 'Special') {\n            if (prefix === 'xml') {\n              if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {\n                throw new Error('InvalidArgumentException: Xml String');\n              } else {\n                kind = 'Implied';\n              }\n            } else {\n              throw new Error('InvalidArgumentException: Prefix \"xmlns\" is reserved for use by XML.');\n            }\n          } else {\n            kind = this.namespaceStack[existingNsIndex].namespaceUri === ns ? 'Implied' : 'NeedToWrite';\n          }\n        }\n      } else {\n        if (ns === 'http://www.w3.org/XML/1998/namespace' && prefix !== 'xml' || ns === 'http://www.w3.org/2000/xmlns/' && prefix !== 'xmlns') {\n          throw new Error('InvalidArgumentException');\n        }\n\n        kind = 'NeedToWrite';\n      }\n\n      this.addNamespace(prefix, ns, kind);\n    }\n  }, {\n    key: \"pushNamespaceExplicit\",\n    value: function pushNamespaceExplicit(prefix, ns) {\n      var existingNsIndex = this.lookupNamespaceIndex(prefix);\n\n      if (existingNsIndex !== -1) {\n        if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n          this.namespaceStack[existingNsIndex].kind = 'Written';\n          return;\n        }\n      }\n\n      this.addNamespace(prefix, ns, 'Written');\n      return;\n    }\n  }, {\n    key: \"addAttribute\",\n    value: function addAttribute(prefix, localName, namespaceName) {\n      var top = this.attributeStack.length;\n      this.attributeStack.push(new XmlAttribute());\n      this.attributeStack[top].set(prefix, localName, namespaceName);\n\n      for (var i = 0; i < top; i++) {\n        if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {\n          throw new Error('XmlException: duplicate attribute name');\n        }\n      }\n    }\n  }, {\n    key: \"skipPushAndWrite\",\n    value: function skipPushAndWrite(prefix, localName, namespace) {\n      this.addAttribute(prefix, localName, namespace);\n      this.writeStartAttributeInternal(prefix, localName, namespace);\n    }\n  }, {\n    key: \"checkName\",\n    value: function checkName(text) {\n      var format = /[ !@#$%^&*()+\\=\\[\\]{};':\"\\\\|,<>\\/?]/;\n\n      if (format.test(text)) {\n        throw new Error('InvalidArgumentException: invalid name character');\n      }\n    }\n  }]);\n\n  return XmlWriter;\n}();\n/**\n * class for managing namespace collection\n */\n\n\nvar Namespace = /*#__PURE__*/function () {\n  function Namespace() {\n    _classCallCheck(this, Namespace);\n  }\n\n  _createClass(Namespace, [{\n    key: \"set\",\n    value:\n    /**\n     * set value for current namespace instance\n     * @param {string} prefix namespace's prefix\n     * @param {string} namespaceUri namespace URI\n     * @param {string} kind namespace kind\n     */\n    function set(prefix, namespaceUri, kind) {\n      this.prefix = prefix;\n      this.namespaceUri = namespaceUri;\n      this.kind = kind;\n    }\n    /**\n     * Releases the resources used by Namespace\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.prefix = undefined;\n      this.namespaceUri = undefined;\n      this.kind = undefined;\n    }\n  }]);\n\n  return Namespace;\n}();\n/**\n * class for managing element collection\n */\n\n\nvar XmlElement = /*#__PURE__*/function () {\n  function XmlElement() {\n    _classCallCheck(this, XmlElement);\n  }\n\n  _createClass(XmlElement, [{\n    key: \"set\",\n    value:\n    /**\n     * set value of current element\n     * @param {string} prefix - element prefix\n     * @param {string} localName - element local name\n     * @param {string} namespaceUri -namespace URI\n     * @param {string} previousTop - previous namespace top\n     */\n    function set(prefix, localName, namespaceUri, previousTop) {\n      this.previousTop = previousTop;\n      this.prefix = prefix;\n      this.namespaceUri = namespaceUri;\n      this.localName = localName;\n    }\n    /**\n     * Releases the resources used by XmlElement\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.previousTop = undefined;\n      this.prefix = undefined;\n      this.localName = undefined;\n      this.namespaceUri = undefined;\n    }\n  }]);\n\n  return XmlElement;\n}();\n/**\n * class for managing attribute collection\n */\n\n\nvar XmlAttribute = /*#__PURE__*/function () {\n  function XmlAttribute() {\n    _classCallCheck(this, XmlAttribute);\n  }\n\n  _createClass(XmlAttribute, [{\n    key: \"set\",\n    value:\n    /**\n     * set value of current attribute\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n    function set(prefix, localName, namespaceUri) {\n      this.prefix = prefix;\n      this.namespaceUri = namespaceUri;\n      this.localName = localName;\n    }\n    /**\n     * get whether the attribute is duplicate or not\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n\n  }, {\n    key: \"isDuplicate\",\n    value: function isDuplicate(prefix, localName, namespaceUri) {\n      return this.localName === localName && (this.prefix === prefix || this.namespaceUri === namespaceUri);\n    }\n    /**\n     * Releases the resources used by XmlAttribute\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.prefix = undefined;\n      this.namespaceUri = undefined;\n      this.localName = undefined;\n    }\n  }]);\n\n  return XmlAttribute;\n}();\n/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\n\n\nvar Encoding = /*#__PURE__*/function () {\n  /**\n   * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n   * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n   */\n  function Encoding(includeBom) {\n    _classCallCheck(this, Encoding);\n\n    this.emitBOM = true;\n    this.encodingType = 'Ansi';\n    this.initBOM(includeBom);\n  }\n  /**\n   * Gets a value indicating whether to write a Unicode byte order mark\n   * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n   */\n\n\n  _createClass(Encoding, [{\n    key: \"includeBom\",\n    get: function get() {\n      return this.emitBOM;\n    }\n    /**\n     * Gets the encoding type.\n     * @returns EncodingType\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.encodingType;\n    }\n    /**\n     * Sets the encoding type.\n     * @param  {EncodingType} value\n     */\n    ,\n    set: function set(value) {\n      this.encodingType = value;\n    }\n    /**\n     * Initialize the includeBom to emit BOM or Not\n     * @param  {boolean} includeBom\n     */\n\n  }, {\n    key: \"initBOM\",\n    value: function initBOM(includeBom) {\n      if (includeBom === undefined || includeBom === null) {\n        this.emitBOM = true;\n      } else {\n        this.emitBOM = includeBom;\n      }\n    }\n    /**\n     * Calculates the number of bytes produced by encoding the characters in the specified string\n     * @param  {string} chars - The string containing the set of characters to encode\n     * @returns {number} - The number of bytes produced by encoding the specified characters\n     */\n\n  }, {\n    key: \"getByteCount\",\n    value: function getByteCount(chars) {\n      validateNullOrUndefined(chars, 'string');\n\n      if (chars === '') {\n        var byte = this.utf8Len(chars.charCodeAt(0));\n        return byte;\n      }\n\n      if (this.type === null || this.type === undefined) {\n        this.type = 'Ansi';\n      }\n\n      return this.getByteCountInternal(chars, 0, chars.length);\n    }\n    /**\n     * Return the Byte of character\n     * @param  {number} codePoint\n     * @returns {number}\n     */\n\n  }, {\n    key: \"utf8Len\",\n    value: function utf8Len(codePoint) {\n      var bytes = codePoint <= 0x7F ? 1 : codePoint <= 0x7FF ? 2 : codePoint <= 0xFFFF ? 3 : codePoint <= 0x1FFFFF ? 4 : 0;\n      return bytes;\n    }\n    /**\n     * for 4 byte character return surrogate pair true, otherwise false\n     * @param  {number} codeUnit\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isHighSurrogate\",\n    value: function isHighSurrogate(codeUnit) {\n      return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n    }\n    /**\n     * for 4byte character generate the surrogate pair\n     * @param  {number} highCodeUnit\n     * @param  {number} lowCodeUnit\n     */\n\n  }, {\n    key: \"toCodepoint\",\n    value: function toCodepoint(highCodeUnit, lowCodeUnit) {\n      highCodeUnit = (0x3FF & highCodeUnit) << 10;\n      var u = highCodeUnit | 0x3FF & lowCodeUnit;\n      return u + 0x10000;\n    }\n    /**\n     * private method to get the byte count for specific charindex and count\n     * @param  {string} chars\n     * @param  {number} charIndex\n     * @param  {number} charCount\n     */\n\n  }, {\n    key: \"getByteCountInternal\",\n    value: function getByteCountInternal(chars, charIndex, charCount) {\n      var byteCount = 0;\n\n      if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n        var isUtf8 = this.encodingType === 'Utf8';\n\n        for (var i = 0; i < charCount; i++) {\n          var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n\n          if (this.isHighSurrogate(charCode)) {\n            if (isUtf8) {\n              var high = charCode;\n              var low = chars.charCodeAt(++charIndex);\n              byteCount += this.utf8Len(this.toCodepoint(high, low));\n            } else {\n              byteCount += 4;\n              ++i;\n            }\n          } else {\n            if (isUtf8) {\n              byteCount += this.utf8Len(charCode);\n            } else {\n              byteCount += 2;\n            }\n          }\n\n          if (isUtf8) {\n            charIndex++;\n          }\n        }\n\n        return byteCount;\n      } else {\n        byteCount = charCount;\n        return byteCount;\n      }\n    }\n    /**\n     * Encodes a set of characters from the specified string into the ArrayBuffer.\n     * @param  {string} s- The string containing the set of characters to encode\n     * @param  {number} charIndex-The index of the first character to encode.\n     * @param  {number} charCount- The number of characters to encode.\n     * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n     */\n\n  }, {\n    key: \"getBytes\",\n    value: function getBytes(s, charIndex, charCount) {\n      validateNullOrUndefined(s, 'string');\n      validateNullOrUndefined(charIndex, 'charIndex');\n      validateNullOrUndefined(charCount, 'charCount');\n\n      if (charIndex < 0 || charCount < 0) {\n        throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n      }\n\n      if (s.length - charIndex < charCount) {\n        throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n      }\n\n      var bytes;\n\n      if (s === '') {\n        bytes = new ArrayBuffer(0);\n        return bytes;\n      }\n\n      if (this.type === null || this.type === undefined) {\n        this.type = 'Ansi';\n      }\n\n      var byteCount = this.getByteCountInternal(s, charIndex, charCount);\n\n      switch (this.type) {\n        case 'Utf8':\n          bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n          return bytes;\n\n        case 'Unicode':\n          bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n          return bytes;\n\n        default:\n          bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n          return bytes;\n      }\n    }\n    /**\n     * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n     * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n     * @param  {number} index- The index of the first byte to decode.\n     * @param  {number} count- The number of bytes to decode.\n     * @returns {string} - The string that contains the resulting set of characters.\n     */\n\n  }, {\n    key: \"getString\",\n    value: function getString(bytes, index, count) {\n      validateNullOrUndefined(bytes, 'bytes');\n      validateNullOrUndefined(index, 'index');\n      validateNullOrUndefined(count, 'count');\n\n      if (index < 0 || count < 0) {\n        throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n      }\n\n      if (bytes.byteLength - index < count) {\n        throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n      }\n\n      if (bytes.byteLength === 0 || count === 0) {\n        return '';\n      }\n\n      if (this.type === null || this.type === undefined) {\n        this.type = 'Ansi';\n      }\n\n      var out = '';\n      var byteCal = new Uint8Array(bytes);\n\n      switch (this.type) {\n        case 'Utf8':\n          var s = this.getStringOfUtf8Encoding(byteCal, index, count);\n          return s;\n\n        case 'Unicode':\n          var byteUnicode = new Uint16Array(bytes);\n          out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n          return out;\n\n        default:\n          var j = index;\n\n          for (var i = 0; i < count; i++) {\n            var c = byteCal[j];\n            out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n\n            j++;\n          }\n\n          return out;\n      }\n    }\n  }, {\n    key: \"getBytesOfAnsiEncoding\",\n    value: function getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount) {\n      var bytes = new ArrayBuffer(byteCount);\n      var bufview = new Uint8Array(bytes);\n      var k = 0;\n\n      for (var i = 0; i < charCount; i++) {\n        var charcode = s.charCodeAt(charIndex++);\n\n        if (charcode < 0x800) {\n          bufview[k] = charcode;\n        } else {\n          bufview[k] = 63; //replacement character '?'\n        }\n\n        k++;\n      }\n\n      return bytes;\n    }\n  }, {\n    key: \"getBytesOfUtf8Encoding\",\n    value: function getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount) {\n      var bytes = new ArrayBuffer(byteCount);\n      var uint = new Uint8Array(bytes);\n      var index = charIndex;\n      var j = 0;\n\n      for (var i = 0; i < charCount; i++) {\n        var charcode = s.charCodeAt(index);\n\n        if (charcode <= 0x7F) {\n          // 1 byte character 2^7\n          uint[j] = charcode;\n        } else if (charcode < 0x800) {\n          // 2 byte character 2^11\n          uint[j] = 0xc0 | charcode >> 6;\n          uint[++j] = 0x80 | charcode & 0x3f;\n        } else if (charcode < 0xd800 || charcode >= 0xe000) {\n          // 3 byte character 2^16        \n          uint[j] = 0xe0 | charcode >> 12;\n          uint[++j] = 0x80 | charcode >> 6 & 0x3f;\n          uint[++j] = 0x80 | charcode & 0x3f;\n        } else {\n          uint[j] = 0xef;\n          uint[++j] = 0xbf;\n          uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n        }\n\n        ++j;\n        ++index;\n      }\n\n      return bytes;\n    }\n  }, {\n    key: \"getBytesOfUnicodeEncoding\",\n    value: function getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount) {\n      var bytes = new ArrayBuffer(byteCount);\n      var uint16 = new Uint16Array(bytes);\n\n      for (var i = 0; i < charCount; i++) {\n        var charcode = s.charCodeAt(i);\n        uint16[i] = charcode;\n      }\n\n      return bytes;\n    }\n  }, {\n    key: \"getStringOfUtf8Encoding\",\n    value: function getStringOfUtf8Encoding(byteCal, index, count) {\n      var j = 0;\n      var i = index;\n      var s = '';\n\n      for (j; j < count; j++) {\n        var c = byteCal[i++];\n\n        while (i > byteCal.length) {\n          return s;\n        }\n\n        if (c > 127) {\n          if (c > 191 && c < 224 && i < count) {\n            c = (c & 31) << 6 | byteCal[i] & 63;\n          } else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n            c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n          } else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n            c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n          }\n\n          ++i;\n        }\n\n        s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n      }\n\n      return s;\n    }\n  }, {\n    key: \"getStringofUnicodeEncoding\",\n    value: function getStringofUnicodeEncoding(byteUni, index, count) {\n      if (count > byteUni.length) {\n        throw new RangeError('ArgumentOutOfRange_Count');\n      }\n\n      var byte16 = new Uint16Array(count);\n      var out = '';\n\n      for (var i = 0; i < count && i < byteUni.length; i++) {\n        byte16[i] = byteUni[index++];\n      }\n\n      out = String.fromCharCode.apply(null, byte16);\n      return out;\n    }\n    /**\n     * To clear the encoding instance\n     * @return {void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.emitBOM = undefined;\n      this.encodingType = undefined;\n    }\n  }]);\n\n  return Encoding;\n}();\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\n\n\nfunction validateNullOrUndefined(value, message) {\n  if (value === null || value === undefined) {\n    throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n  }\n}\n/**\n * StreamWriter class contains the implementation for writing characters to a file in a particular encoding\n * ```typescript\n * let writer = new StreamWriter();\n * writer.write('Hello World');\n * writer.save('Sample.txt');\n * writer.dispose();\n * ```\n */\n\n\nvar StreamWriter = /*#__PURE__*/function () {\n  /**\n   * Initializes a new instance of the StreamWriter class by using the specified encoding.\n   * @param  {Encoding} encoding?- The character encoding to use.\n   */\n  function StreamWriter(encoding) {\n    _classCallCheck(this, StreamWriter);\n\n    this.bufferBlob = new Blob(['']);\n    this.bufferText = '';\n    this.init(encoding);\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n\n  _createClass(StreamWriter, [{\n    key: \"buffer\",\n    get:\n    /**\n     * Gets the content written to the StreamWriter as Blob.\n     * @returns Blob\n     */\n    function get() {\n      this.flush();\n      return this.bufferBlob;\n    }\n    /**\n     * Gets the encoding.\n     * @returns Encoding\n     */\n\n  }, {\n    key: \"encoding\",\n    get: function get() {\n      return this.enc;\n    }\n  }, {\n    key: \"init\",\n    value: function init(encoding) {\n      if (encoding === null || encoding === undefined) {\n        this.enc = new Encoding(false);\n        this.enc.type = 'Utf8';\n      } else {\n        this.enc = encoding;\n        this.setBomByte();\n      }\n    }\n    /**\n     * Private method to set Byte Order Mark(BOM) value based on EncodingType\n     */\n\n  }, {\n    key: \"setBomByte\",\n    value: function setBomByte() {\n      if (this.encoding.includeBom) {\n        switch (this.encoding.type) {\n          case 'Unicode':\n            var arrayUnicode = new ArrayBuffer(2);\n            var uint8 = new Uint8Array(arrayUnicode);\n            uint8[0] = 255;\n            uint8[1] = 254;\n            this.bufferBlob = new Blob([arrayUnicode]);\n            break;\n\n          case 'Utf8':\n            var arrayUtf8 = new ArrayBuffer(3);\n            var utf8 = new Uint8Array(arrayUtf8);\n            utf8[0] = 239;\n            utf8[1] = 187;\n            utf8[2] = 191;\n            this.bufferBlob = new Blob([arrayUtf8]);\n            break;\n\n          default:\n            this.bufferBlob = new Blob(['']);\n            break;\n        }\n      }\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName - The file name to save\n     * @returns {void}\n     */\n\n  }, {\n    key: \"save\",\n    value: function save(fileName) {\n      if (this.bufferText !== '') {\n        this.flush();\n      }\n\n      Save.save(fileName, this.buffer);\n    }\n    /**\n     * Writes the specified string.\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(value) {\n      if (this.encoding === undefined) {\n        throw new Error('Object Disposed Exception: current writer is disposed');\n      }\n\n      validateNullOrUndefined(value, 'string');\n      this.bufferText += value;\n\n      if (this.bufferText.length >= 10240) {\n        this.flush();\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this.bufferText === undefined || this.bufferText === null || this.bufferText.length === 0) {\n        return;\n      }\n\n      var bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);\n      this.bufferText = '';\n      this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);\n    }\n    /**\n     * Writes the specified string followed by a line terminator\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written\n     * @returns {void}\n     */\n\n  }, {\n    key: \"writeLine\",\n    value: function writeLine(value) {\n      if (this.encoding === undefined) {\n        throw new Error('Object Disposed Exception: current writer is disposed');\n      }\n\n      validateNullOrUndefined(value, 'string');\n      this.bufferText = this.bufferText + value + '\\r\\n';\n\n      if (this.bufferText.length >= 10240) {\n        this.flush();\n      }\n    }\n    /**\n     * Releases the resources used by the StreamWriter\n     * @returns {void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.bufferBlob = undefined;\n      this.bufferText = undefined;\n\n      if (this.enc instanceof Encoding) {\n        this.enc.destroy();\n      }\n\n      this.enc = undefined;\n    }\n  }]);\n\n  return StreamWriter;\n}(); // export all modules from current location\n// example: export * from './module'\n\n/**\n * file utils modules\n */\n\n\nexport { XmlWriter, Namespace, XmlElement, XmlAttribute, StreamWriter, Encoding, validateNullOrUndefined, Save };","map":{"version":3,"sources":["D:/angularStarter/11-24/syncfusion-mytemplate/template-v1/node_modules/@syncfusion/ej2-file-utils/dist/es6/ej2-file-utils.es2015.js"],"names":["Save","fileName","buffer","undefined","Error","extension","substring","lastIndexOf","length","mimeType","getMimeType","Blob","type","isMicrosoftBrowser","navigator","msSaveBlob","downloadLink","document","createElementNS","saveInternal","hasDownloadAttribute","download","dataUrl","window","URL","createObjectURL","href","event","createEvent","initEvent","dispatchEvent","setTimeout","revokeObjectURL","url","isPopupBlocked","open","location","reader","FileReader","onloadend","result","readAsDataURL","XmlWriter","contentPos","bufferText","bufferBlob","currentState","namespaceStack","push","Namespace","set","elementStack","XmlElement","attributeStack","flush","name","text","checkName","writeStartDocument","writeProcessingInstructionInternal","standalone","rawText","writeEndElement","prefix","localName","namespace","startElementContent","lookupPrefix","lookupNamespace","writeStartElementInternal","top","writeEndElementInternal","splice","previousTop","value","writeStartElement","writeString","writeStartAttribute","writeStringInternal","writeEndAttribute","writeInternal","isRawString","save","i","destroy","replace","writeStartAttributePrefixAndNameSpace","writeStartAttributeSpecialAttribute","skipPushAndWrite","pushNamespaceExplicit","pushNamespaceImplicit","namespaceName","namespaceUri","writeStartNamespaceDeclaration","inAttributeValue","start","kind","writeNamespaceDeclaration","ns","existingNsIndex","lookupNamespaceIndex","addNamespace","XmlAttribute","isDuplicate","addAttribute","writeStartAttributeInternal","format","test","Encoding","includeBom","emitBOM","encodingType","initBOM","chars","validateNullOrUndefined","byte","utf8Len","charCodeAt","getByteCountInternal","codePoint","bytes","codeUnit","highCodeUnit","lowCodeUnit","u","charIndex","charCount","byteCount","isUtf8","charCode","isHighSurrogate","high","low","toCodepoint","s","RangeError","ArrayBuffer","getBytesOfUtf8Encoding","getBytesOfUnicodeEncoding","getBytesOfAnsiEncoding","index","count","byteLength","out","byteCal","Uint8Array","getStringOfUtf8Encoding","byteUnicode","Uint16Array","getStringofUnicodeEncoding","j","c","String","fromCharCode","bufview","k","charcode","uint","uint16","byteUni","byte16","apply","message","StreamWriter","encoding","init","enc","setBomByte","arrayUnicode","uint8","arrayUtf8","utf8","bufferArray","getBytes"],"mappings":"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","sourcesContent":["/**\n * Save class provide method to save file\n * ```typescript\n * let blob : Blob = new Blob([''], { type: 'text/plain' });\n * Save.save('fileName.txt',blob);\n */\nclass Save {\n    /**\n     * Initialize new instance of {save}\n     */\n    constructor() {\n        // tslint:disable\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName- file name to save.\n     * @param  {Blob} buffer- the content to write in file\n     * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not\n     * @returns {void}\n     */\n    static save(fileName, buffer) {\n        if (fileName === null || fileName === undefined || fileName === '') {\n            throw new Error('ArgumentException: fileName cannot be undefined, null or empty');\n        }\n        let extension = fileName.substring(fileName.lastIndexOf('.') + 1, fileName.length);\n        let mimeType = this.getMimeType(extension);\n        if (mimeType !== '') {\n            buffer = new Blob([buffer], { type: mimeType });\n        }\n        if (this.isMicrosoftBrowser) {\n            navigator.msSaveBlob(buffer, fileName);\n        }\n        else {\n            let downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n            this.saveInternal(fileName, extension, buffer, downloadLink, 'download' in downloadLink);\n        }\n    }\n    static saveInternal(fileName, extension, buffer, downloadLink, hasDownloadAttribute) {\n        if (hasDownloadAttribute) {\n            downloadLink.download = fileName;\n            let dataUrl = window.URL.createObjectURL(buffer);\n            downloadLink.href = dataUrl;\n            let event = document.createEvent('MouseEvent');\n            event.initEvent('click', true, true);\n            downloadLink.dispatchEvent(event);\n            setTimeout(() => {\n                window.URL.revokeObjectURL(dataUrl);\n                dataUrl = undefined;\n            });\n        }\n        else {\n            if (extension !== 'docx' && extension !== 'xlsx') {\n                let url = window.URL.createObjectURL(buffer);\n                let isPopupBlocked = window.open(url, '_blank');\n                if (!isPopupBlocked) {\n                    window.location.href = url;\n                }\n            }\n            else {\n                let reader = new FileReader();\n                reader.onloadend = () => {\n                    let isPopupBlocked = window.open(reader.result, '_blank');\n                    if (!isPopupBlocked) {\n                        window.location.href = reader.result;\n                    }\n                };\n                reader.readAsDataURL(buffer);\n            }\n        }\n    }\n    /**\n     *\n     * @param {string} extension - get mime type of the specified extension\n     * @private\n     */\n    static getMimeType(extension) {\n        let mimeType = '';\n        switch (extension) {\n            case 'html':\n                mimeType = 'text/html';\n                break;\n            case 'pdf':\n                mimeType = 'application/pdf';\n                break;\n            case 'docx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n                break;\n            case 'xlsx':\n                mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n                break;\n            case 'txt':\n                mimeType = 'text/plain';\n                break;\n        }\n        return mimeType;\n    }\n}\n\n/**\n * XmlWriter class provide method to create XML data\n */\nclass XmlWriter {\n    /**\n     * Initialize new instance of {XmlWriter}\n     */\n    constructor() {\n        this.contentPos = 0;\n        this.bufferText = '';\n        this.bufferBlob = new Blob([''], { type: 'text/plain' });\n        this.currentState = 'Initial';\n        this.namespaceStack = [];\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[0].set('xmlns', 'http://www.w3.org/2000/xmlns/', 'Special');\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[1].set('xml', 'http://www.w3.org/XML/1998/namespace', 'Special');\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[2].set('', '', 'Implied');\n        this.elementStack = [];\n        this.elementStack.push(new XmlElement());\n        this.elementStack[0].set('', '', '', this.namespaceStack.length - 1);\n        this.attributeStack = [];\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    /**\n     * Gets the content written to the {XmlWriter} as Blob.\n     * @returns {Blob}\n     */\n    get buffer() {\n        this.flush();\n        return this.bufferBlob;\n    }\n    /**\n     * Writes processing instruction with a space between the name and text\n     * @param {string} name - name of the processing instruction\n     * @param {string} text - text to write in the processing instruction\n     * @throws ArgumentException\n     * @throws InvalidArgumentException\n     * @throws InvalidOperationException\n     */\n    writeProcessingInstruction(name, text) {\n        if (name === undefined || name === null || name.length === 0) {\n            throw new Error('ArgumentException: name should not be undefined, null or empty');\n        }\n        this.checkName(name);\n        if (text === undefined || text === null) {\n            text = '';\n        }\n        if (name.length === 3 && name === 'xml') {\n            if (this.currentState !== 'Initial') {\n                // tslint:disable-next-line:max-line-length\n                throw new Error('InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it');\n            }\n        }\n        if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        else {\n            this.writeStartDocument();\n            this.writeProcessingInstructionInternal(name, text);\n        }\n    }\n    /**\n     * Writes Xml declaration with version and standalone attribute\n     * @param {boolean} standalone - if true it write standalone=yes else standalone=no\n     * @throws InvalidOperation\n     */\n    writeStartDocument(standalone) {\n        if (this.currentState !== 'Initial' || this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        this.currentState = 'StartDocument';\n        this.rawText('<?xml version=\"1.0\" encoding=\"utf-8');\n        if (standalone !== null && standalone !== undefined) {\n            this.rawText('\" standalone=\"');\n            this.rawText(standalone ? 'yes' : 'no');\n        }\n        this.rawText('\"?>');\n    }\n    /**\n     * Closes any open tag or attribute and write the state back to start\n     */\n    writeEndDocument() {\n        while (this.elementStack.length - 1 > 0) {\n            this.writeEndElement();\n        }\n        this.currentState = 'EndDocument';\n        this.flush();\n    }\n    /**\n     * Writes the specified start tag and associates it with the given namespace and prefix.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName -localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @throws ArgumentException\n     * @throws InvalidOperationException\n     */\n    writeStartElement(prefix, localName, namespace) {\n        if (this.bufferBlob === undefined) {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        if (localName === undefined || localName === null || localName.length === 0) {\n            throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n        }\n        this.checkName(localName);\n        if (this.currentState === 'Initial') {\n            this.writeStartDocument();\n        }\n        if (this.currentState === 'StartElement') {\n            this.startElementContent();\n        }\n        this.currentState = 'StartElement';\n        if (prefix === undefined || prefix === null) {\n            if (namespace !== undefined && namespace !== null) {\n                prefix = this.lookupPrefix(namespace);\n            }\n            if (prefix === undefined || prefix === null) {\n                prefix = '';\n            }\n        }\n        else if (prefix.length > 0) {\n            if (namespace === undefined || namespace === null) {\n                namespace = this.lookupNamespace(prefix);\n            }\n            if (namespace === undefined || namespace === null || (namespace !== undefined && namespace.length === 0)) {\n                throw new Error('ArgumentException: Cannot use a prefix with an empty namespace');\n            }\n        }\n        if (namespace === undefined || namespace === null) {\n            namespace = this.lookupNamespace(prefix);\n        }\n        this.writeStartElementInternal(prefix, localName, namespace);\n    }\n    /**\n     * Closes one element and pop corresponding namespace scope\n     */\n    writeEndElement() {\n        if (this.currentState === 'StartElement') {\n            this.startElementContent();\n            this.currentState = 'ElementContent';\n        }\n        else if (this.currentState === 'ElementContent') {\n            this.currentState = 'ElementContent';\n        }\n        this.currentState = 'EndElement';\n        let top = this.elementStack.length - 1;\n        this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);\n        this.namespaceStack.splice(this.elementStack[top].previousTop + 1);\n        this.elementStack.splice(top);\n        if (this.bufferText.length > 10240) {\n            this.flush();\n        }\n    }\n    /**\n     * Writes an element with the specified prefix, local name, namespace URI, and value.\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n    writeElementString(prefix, localName, namespace, value) {\n        this.writeStartElement(prefix, localName, namespace);\n        if (value !== undefined && value !== null && value.length !== 0) {\n            this.writeString(value);\n        }\n        this.writeEndElement();\n    }\n    /**\n     * Writes out the attribute with the specified prefix, local name, namespace URI, and value\n     * @param {string} prefix - namespace prefix of element\n     * @param {string} localName - localName of element\n     * @param {string} namespace - namespace URI associate with element\n     * @param {string} value - value of element\n     */\n    writeAttributeString(prefix, localName, namespace, value) {\n        this.writeStartAttribute(prefix, localName, namespace, value);\n        this.writeStringInternal(value, true);\n        this.writeEndAttribute();\n    }\n    /**\n     * Writes the given text content\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n    writeString(text) {\n        this.writeInternal(text, false);\n    }\n    /**\n     * Write given text as raw data\n     * @param {string} text - text to write\n     * @throws InvalidOperationException\n     */\n    writeRaw(text) {\n        this.writeInternal(text, true);\n    }\n    writeInternal(text, isRawString) {\n        if (text === undefined || text === null) {\n            return;\n        }\n        else {\n            if (this.currentState !== 'StartElement' && this.currentState !== 'ElementContent') {\n                throw new Error('InvalidOperationException: Wrong Token');\n            }\n            if (this.currentState === 'StartElement') {\n                this.startElementContent();\n            }\n            this.currentState = 'ElementContent';\n            if (isRawString) {\n                this.rawText(text);\n            }\n            else {\n                this.writeStringInternal(text, false);\n            }\n        }\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param {string} fileName - file name\n     */\n    save(fileName) {\n        while (this.elementStack.length - 1 > 0) {\n            this.writeEndElement();\n        }\n        if (this.bufferText !== '') {\n            this.flush();\n        }\n        Save.save(fileName, this.buffer);\n    }\n    /**\n     * Releases the resources used by XmlWriter.\n     */\n    destroy() {\n        this.bufferBlob = undefined;\n        for (let i = 0; i < this.namespaceStack.length; i++) {\n            this.namespaceStack[i].destroy();\n        }\n        this.namespaceStack = [];\n        for (let i = 0; i < this.elementStack.length; i++) {\n            this.elementStack[i].destroy();\n        }\n        this.elementStack = [];\n        this.bufferText = '';\n        this.contentPos = 0;\n    }\n    flush() {\n        if (this.bufferBlob === undefined) {\n            return;\n        }\n        this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], { type: 'text/plain' });\n        this.bufferText = '';\n    }\n    writeProcessingInstructionInternal(name, text) {\n        this.bufferText += '<?';\n        this.rawText(name);\n        if (text.length > 0) {\n            this.bufferText += ' ';\n            text = text.replace(/\\?\\>/g, '? >');\n            this.bufferText += text;\n        }\n        this.bufferText += '?';\n        this.bufferText += '>';\n    }\n    writeStartAttribute(prefix, localName, namespace, value) {\n        if (localName === undefined || localName === null || localName.length === 0) {\n            if (prefix === 'xmlns') {\n                localName = 'xmlns';\n                prefix = '';\n            }\n            else {\n                throw new Error('ArgumentException: localName cannot be undefined, null or empty');\n            }\n        }\n        if (this.currentState !== 'StartElement') {\n            throw new Error('InvalidOperationException: Wrong Token');\n        }\n        this.checkName(localName);\n        this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);\n    }\n    writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value) {\n        if (prefix === undefined || prefix === null) {\n            if (namespace !== undefined && namespace !== null) {\n                if (!(localName === 'xmlns' && namespace === 'http://www.w3.org/2000/xmlns/')) {\n                    prefix = this.lookupPrefix(namespace);\n                }\n            }\n            if (prefix === undefined || prefix === null) {\n                prefix = '';\n            }\n        }\n        if (namespace === undefined || namespace === null) {\n            if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n                namespace = this.lookupNamespace(prefix);\n            }\n            if (namespace === undefined || namespace === null) {\n                namespace = '';\n            }\n        }\n        this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);\n    }\n    writeStartAttributeSpecialAttribute(prefix, localName, namespace, value) {\n        if (prefix.length === 0) {\n            if (localName[0] === 'x' && localName === 'xmlns') {\n                this.skipPushAndWrite(prefix, localName, namespace);\n                this.pushNamespaceExplicit('', value);\n                return;\n            }\n            else if (namespace.length > 0) {\n                prefix = this.lookupPrefix(namespace);\n            }\n        }\n        else {\n            if (prefix[0] === 'x') {\n                if (prefix === 'xmlns') {\n                    this.skipPushAndWrite(prefix, localName, namespace);\n                    this.pushNamespaceExplicit(localName, value);\n                    return;\n                }\n                else if (prefix === 'xml') {\n                    if (localName === 'space' || localName === 'lang') {\n                        this.skipPushAndWrite(prefix, localName, namespace);\n                        return;\n                    }\n                }\n            }\n            if (namespace.length === 0) {\n                prefix = '';\n            }\n        }\n        if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n            this.pushNamespaceImplicit(prefix, namespace);\n        }\n        this.skipPushAndWrite(prefix, localName, namespace);\n    }\n    writeEndAttribute() {\n        this.currentState = 'StartElement';\n        this.bufferText += '\"';\n    }\n    writeStartElementInternal(prefix, localName, namespace) {\n        this.bufferText += '<';\n        if (prefix.length > 0) {\n            this.rawText(prefix);\n            this.bufferText += ':';\n        }\n        this.rawText(localName);\n        let top = this.elementStack.length;\n        this.elementStack.push(new XmlElement());\n        this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);\n        this.pushNamespaceImplicit(prefix, namespace);\n        for (let i = 0; i < this.attributeStack.length; i++) {\n            this.attributeStack[i].destroy();\n        }\n        this.attributeStack = [];\n    }\n    writeEndElementInternal(prefix, localName) {\n        if (this.contentPos !== this.bufferText.length + 1) {\n            this.bufferText += '</';\n            if (prefix !== undefined && prefix !== null && prefix.length !== 0) {\n                this.rawText(prefix);\n                this.bufferText += ':';\n            }\n            this.rawText(localName);\n            this.bufferText += '>';\n        }\n        else {\n            this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);\n            this.bufferText += ' />';\n        }\n    }\n    writeStartAttributeInternal(prefix, localName, namespaceName) {\n        this.bufferText += ' ';\n        if (prefix !== undefined && prefix !== null && prefix.length > 0) {\n            this.rawText(prefix);\n            this.bufferText += ':';\n        }\n        this.rawText(localName);\n        this.bufferText += '=';\n        this.bufferText += '\"';\n    }\n    writeNamespaceDeclaration(prefix, namespaceUri) {\n        this.writeStartNamespaceDeclaration(prefix);\n        this.writeStringInternal(namespaceUri, true);\n        this.bufferText += '\"';\n    }\n    writeStartNamespaceDeclaration(prefix) {\n        if (prefix === undefined || prefix === null || prefix.length === 0) {\n            this.rawText(' xmlns=\\\"');\n        }\n        else {\n            this.rawText(' xmlns:');\n            this.rawText(prefix);\n            this.bufferText += '=';\n            this.bufferText += '\"';\n        }\n    }\n    writeStringInternal(text, inAttributeValue) {\n        if (text === null || text === undefined) {\n            text = '';\n        }\n        text = text.replace(/\\&/g, '&amp;');\n        text = text.replace(/\\</g, '&lt;');\n        text = text.replace(/\\>/g, '&gt;');\n        if (inAttributeValue) {\n            text = text.replace(/\\\"/g, '&quot;');\n        }\n        this.bufferText += text;\n        if (!inAttributeValue) {\n            this.contentPos = 0;\n        }\n    }\n    startElementContent() {\n        let start = this.elementStack[this.elementStack.length - 1].previousTop;\n        for (let i = this.namespaceStack.length - 1; i > start; i--) {\n            if (this.namespaceStack[i].kind === 'NeedToWrite') {\n                this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);\n            }\n        }\n        this.bufferText += '>';\n        this.contentPos = this.bufferText.length + 1;\n    }\n    rawText(text) {\n        this.bufferText += text;\n    }\n    addNamespace(prefix, ns, kind) {\n        let top = this.namespaceStack.length;\n        this.namespaceStack.push(new Namespace());\n        this.namespaceStack[top].set(prefix, ns, kind);\n    }\n    lookupPrefix(namespace) {\n        for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].namespaceUri === namespace) {\n                return this.namespaceStack[i].prefix;\n            }\n        }\n        return undefined;\n    }\n    lookupNamespace(prefix) {\n        for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].prefix === prefix) {\n                return this.namespaceStack[i].namespaceUri;\n            }\n        }\n        return undefined;\n    }\n    lookupNamespaceIndex(prefix) {\n        for (let i = this.namespaceStack.length - 1; i >= 0; i--) {\n            if (this.namespaceStack[i].prefix === prefix) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    pushNamespaceImplicit(prefix, ns) {\n        let kind;\n        let existingNsIndex = this.lookupNamespaceIndex(prefix);\n        if (existingNsIndex !== -1) {\n            if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n                if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {\n                    throw new Error('XmlException namespace Uri needs to be the same as the one that is already declared');\n                }\n                return;\n            }\n            else {\n                if (this.namespaceStack[existingNsIndex].kind === 'Special') {\n                    if (prefix === 'xml') {\n                        if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {\n                            throw new Error('InvalidArgumentException: Xml String');\n                        }\n                        else {\n                            kind = 'Implied';\n                        }\n                    }\n                    else {\n                        throw new Error('InvalidArgumentException: Prefix \"xmlns\" is reserved for use by XML.');\n                    }\n                }\n                else {\n                    kind = (this.namespaceStack[existingNsIndex].namespaceUri === ns) ? 'Implied' : 'NeedToWrite';\n                }\n            }\n        }\n        else {\n            if ((ns === 'http://www.w3.org/XML/1998/namespace' && prefix !== 'xml') ||\n                (ns === 'http://www.w3.org/2000/xmlns/' && prefix !== 'xmlns')) {\n                throw new Error('InvalidArgumentException');\n            }\n            kind = 'NeedToWrite';\n        }\n        this.addNamespace(prefix, ns, kind);\n    }\n    pushNamespaceExplicit(prefix, ns) {\n        let existingNsIndex = this.lookupNamespaceIndex(prefix);\n        if (existingNsIndex !== -1) {\n            if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {\n                this.namespaceStack[existingNsIndex].kind = 'Written';\n                return;\n            }\n        }\n        this.addNamespace(prefix, ns, 'Written');\n        return;\n    }\n    addAttribute(prefix, localName, namespaceName) {\n        let top = this.attributeStack.length;\n        this.attributeStack.push(new XmlAttribute());\n        this.attributeStack[top].set(prefix, localName, namespaceName);\n        for (let i = 0; i < top; i++) {\n            if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {\n                throw new Error('XmlException: duplicate attribute name');\n            }\n        }\n    }\n    skipPushAndWrite(prefix, localName, namespace) {\n        this.addAttribute(prefix, localName, namespace);\n        this.writeStartAttributeInternal(prefix, localName, namespace);\n    }\n    checkName(text) {\n        let format = /[ !@#$%^&*()+\\=\\[\\]{};':\"\\\\|,<>\\/?]/;\n        if (format.test(text)) {\n            throw new Error('InvalidArgumentException: invalid name character');\n        }\n    }\n}\n/**\n * class for managing namespace collection\n */\nclass Namespace {\n    /**\n     * set value for current namespace instance\n     * @param {string} prefix namespace's prefix\n     * @param {string} namespaceUri namespace URI\n     * @param {string} kind namespace kind\n     */\n    set(prefix, namespaceUri, kind) {\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.kind = kind;\n    }\n    /**\n     * Releases the resources used by Namespace\n     */\n    destroy() {\n        this.prefix = undefined;\n        this.namespaceUri = undefined;\n        this.kind = undefined;\n    }\n}\n/**\n * class for managing element collection\n */\nclass XmlElement {\n    /**\n     * set value of current element\n     * @param {string} prefix - element prefix\n     * @param {string} localName - element local name\n     * @param {string} namespaceUri -namespace URI\n     * @param {string} previousTop - previous namespace top\n     */\n    set(prefix, localName, namespaceUri, previousTop) {\n        this.previousTop = previousTop;\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.localName = localName;\n    }\n    /**\n     * Releases the resources used by XmlElement\n     */\n    destroy() {\n        this.previousTop = undefined;\n        this.prefix = undefined;\n        this.localName = undefined;\n        this.namespaceUri = undefined;\n    }\n}\n/**\n * class for managing attribute collection\n */\nclass XmlAttribute {\n    /**\n     * set value of current attribute\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n    set(prefix, localName, namespaceUri) {\n        this.prefix = prefix;\n        this.namespaceUri = namespaceUri;\n        this.localName = localName;\n    }\n    /**\n     * get whether the attribute is duplicate or not\n     * @param {string} prefix - namespace's prefix\n     * @param {string} namespaceUri - namespace URI\n     * @param {string} localName - attribute localName\n     */\n    isDuplicate(prefix, localName, namespaceUri) {\n        return ((this.localName === localName) && ((this.prefix === prefix) || (this.namespaceUri === namespaceUri)));\n    }\n    /**\n     * Releases the resources used by XmlAttribute\n     */\n    destroy() {\n        this.prefix = undefined;\n        this.namespaceUri = undefined;\n        this.localName = undefined;\n    }\n}\n\n/**\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\n * ```typescript\n * let encoding : Encoding = new Encoding();\n * encoding.type = 'Utf8';\n * encoding.getBytes('Encoding', 0, 5);\n * ```\n */\nclass Encoding {\n    /**\n     * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\n     * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\n     */\n    constructor(includeBom) {\n        this.emitBOM = true;\n        this.encodingType = 'Ansi';\n        this.initBOM(includeBom);\n    }\n    /**\n     * Gets a value indicating whether to write a Unicode byte order mark\n     * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\n     */\n    get includeBom() {\n        return this.emitBOM;\n    }\n    /**\n     * Gets the encoding type.\n     * @returns EncodingType\n     */\n    get type() {\n        return this.encodingType;\n    }\n    /**\n     * Sets the encoding type.\n     * @param  {EncodingType} value\n     */\n    set type(value) {\n        this.encodingType = value;\n    }\n    /**\n     * Initialize the includeBom to emit BOM or Not\n     * @param  {boolean} includeBom\n     */\n    initBOM(includeBom) {\n        if (includeBom === undefined || includeBom === null) {\n            this.emitBOM = true;\n        }\n        else {\n            this.emitBOM = includeBom;\n        }\n    }\n    /**\n     * Calculates the number of bytes produced by encoding the characters in the specified string\n     * @param  {string} chars - The string containing the set of characters to encode\n     * @returns {number} - The number of bytes produced by encoding the specified characters\n     */\n    getByteCount(chars) {\n        validateNullOrUndefined(chars, 'string');\n        if (chars === '') {\n            let byte = this.utf8Len(chars.charCodeAt(0));\n            return byte;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        return this.getByteCountInternal(chars, 0, chars.length);\n    }\n    /**\n     * Return the Byte of character\n     * @param  {number} codePoint\n     * @returns {number}\n     */\n    utf8Len(codePoint) {\n        let bytes = codePoint <= 0x7F ? 1 :\n            codePoint <= 0x7FF ? 2 :\n                codePoint <= 0xFFFF ? 3 :\n                    codePoint <= 0x1FFFFF ? 4 : 0;\n        return bytes;\n    }\n    /**\n     * for 4 byte character return surrogate pair true, otherwise false\n     * @param  {number} codeUnit\n     * @returns {boolean}\n     */\n    isHighSurrogate(codeUnit) {\n        return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n    }\n    /**\n     * for 4byte character generate the surrogate pair\n     * @param  {number} highCodeUnit\n     * @param  {number} lowCodeUnit\n     */\n    toCodepoint(highCodeUnit, lowCodeUnit) {\n        highCodeUnit = (0x3FF & highCodeUnit) << 10;\n        let u = highCodeUnit | (0x3FF & lowCodeUnit);\n        return u + 0x10000;\n    }\n    /**\n     * private method to get the byte count for specific charindex and count\n     * @param  {string} chars\n     * @param  {number} charIndex\n     * @param  {number} charCount\n     */\n    getByteCountInternal(chars, charIndex, charCount) {\n        let byteCount = 0;\n        if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n            let isUtf8 = this.encodingType === 'Utf8';\n            for (let i = 0; i < charCount; i++) {\n                let charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n                if (this.isHighSurrogate(charCode)) {\n                    if (isUtf8) {\n                        let high = charCode;\n                        let low = chars.charCodeAt(++charIndex);\n                        byteCount += this.utf8Len(this.toCodepoint(high, low));\n                    }\n                    else {\n                        byteCount += 4;\n                        ++i;\n                    }\n                }\n                else {\n                    if (isUtf8) {\n                        byteCount += this.utf8Len(charCode);\n                    }\n                    else {\n                        byteCount += 2;\n                    }\n                }\n                if (isUtf8) {\n                    charIndex++;\n                }\n            }\n            return byteCount;\n        }\n        else {\n            byteCount = charCount;\n            return byteCount;\n        }\n    }\n    /**\n     * Encodes a set of characters from the specified string into the ArrayBuffer.\n     * @param  {string} s- The string containing the set of characters to encode\n     * @param  {number} charIndex-The index of the first character to encode.\n     * @param  {number} charCount- The number of characters to encode.\n     * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\n     */\n    getBytes(s, charIndex, charCount) {\n        validateNullOrUndefined(s, 'string');\n        validateNullOrUndefined(charIndex, 'charIndex');\n        validateNullOrUndefined(charCount, 'charCount');\n        if (charIndex < 0 || charCount < 0) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n        }\n        if (s.length - charIndex < charCount) {\n            throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n        }\n        let bytes;\n        if (s === '') {\n            bytes = new ArrayBuffer(0);\n            return bytes;\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        let byteCount = this.getByteCountInternal(s, charIndex, charCount);\n        switch (this.type) {\n            case 'Utf8':\n                bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            case 'Unicode':\n                bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n            default:\n                bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n                return bytes;\n        }\n    }\n    /**\n     * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\n     * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\n     * @param  {number} index- The index of the first byte to decode.\n     * @param  {number} count- The number of bytes to decode.\n     * @returns {string} - The string that contains the resulting set of characters.\n     */\n    getString(bytes, index, count) {\n        validateNullOrUndefined(bytes, 'bytes');\n        validateNullOrUndefined(index, 'index');\n        validateNullOrUndefined(count, 'count');\n        if (index < 0 || count < 0) {\n            throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n        }\n        if (bytes.byteLength - index < count) {\n            throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n        }\n        if (bytes.byteLength === 0 || count === 0) {\n            return '';\n        }\n        if (this.type === null || this.type === undefined) {\n            this.type = 'Ansi';\n        }\n        let out = '';\n        let byteCal = new Uint8Array(bytes);\n        switch (this.type) {\n            case 'Utf8':\n                let s = this.getStringOfUtf8Encoding(byteCal, index, count);\n                return s;\n            case 'Unicode':\n                let byteUnicode = new Uint16Array(bytes);\n                out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n                return out;\n            default:\n                let j = index;\n                for (let i = 0; i < count; i++) {\n                    let c = byteCal[j];\n                    out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n                    j++;\n                }\n                return out;\n        }\n    }\n    getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount) {\n        let bytes = new ArrayBuffer(byteCount);\n        let bufview = new Uint8Array(bytes);\n        let k = 0;\n        for (let i = 0; i < charCount; i++) {\n            let charcode = s.charCodeAt(charIndex++);\n            if (charcode < 0x800) {\n                bufview[k] = charcode;\n            }\n            else {\n                bufview[k] = 63; //replacement character '?'\n            }\n            k++;\n        }\n        return bytes;\n    }\n    getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount) {\n        let bytes = new ArrayBuffer(byteCount);\n        let uint = new Uint8Array(bytes);\n        let index = charIndex;\n        let j = 0;\n        for (let i = 0; i < charCount; i++) {\n            let charcode = s.charCodeAt(index);\n            if (charcode <= 0x7F) { // 1 byte character 2^7\n                uint[j] = charcode;\n            }\n            else if (charcode < 0x800) { // 2 byte character 2^11\n                uint[j] = 0xc0 | (charcode >> 6);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else if ((charcode < 0xd800 || charcode >= 0xe000)) { // 3 byte character 2^16        \n                uint[j] = 0xe0 | (charcode >> 12);\n                uint[++j] = 0x80 | ((charcode >> 6) & 0x3f);\n                uint[++j] = 0x80 | (charcode & 0x3f);\n            }\n            else {\n                uint[j] = 0xef;\n                uint[++j] = 0xbf;\n                uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n            }\n            ++j;\n            ++index;\n        }\n        return bytes;\n    }\n    getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount) {\n        let bytes = new ArrayBuffer(byteCount);\n        let uint16 = new Uint16Array(bytes);\n        for (let i = 0; i < charCount; i++) {\n            let charcode = s.charCodeAt(i);\n            uint16[i] = charcode;\n        }\n        return bytes;\n    }\n    getStringOfUtf8Encoding(byteCal, index, count) {\n        let j = 0;\n        let i = index;\n        let s = '';\n        for (j; j < count; j++) {\n            let c = byteCal[i++];\n            while (i > byteCal.length) {\n                return s;\n            }\n            if (c > 127) {\n                if (c > 191 && c < 224 && i < count) {\n                    c = (c & 31) << 6 | byteCal[i] & 63;\n                }\n                else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n                    c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n                    c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n                }\n                ++i;\n            }\n            s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n        }\n        return s;\n    }\n    getStringofUnicodeEncoding(byteUni, index, count) {\n        if (count > byteUni.length) {\n            throw new RangeError('ArgumentOutOfRange_Count');\n        }\n        let byte16 = new Uint16Array(count);\n        let out = '';\n        for (let i = 0; i < count && i < byteUni.length; i++) {\n            byte16[i] = byteUni[index++];\n        }\n        out = String.fromCharCode.apply(null, byte16);\n        return out;\n    }\n    /**\n     * To clear the encoding instance\n     * @return {void}\n     */\n    destroy() {\n        this.emitBOM = undefined;\n        this.encodingType = undefined;\n    }\n}\n/**\n * To check the object is null or undefined and throw error if it is null or undefined\n * @param {Object} value - object to check is null or undefined\n * @return {boolean}\n * @throws {ArgumentException} - if the value is null or undefined\n * @private\n */\nfunction validateNullOrUndefined(value, message) {\n    if (value === null || value === undefined) {\n        throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n    }\n}\n\n/**\n * StreamWriter class contains the implementation for writing characters to a file in a particular encoding\n * ```typescript\n * let writer = new StreamWriter();\n * writer.write('Hello World');\n * writer.save('Sample.txt');\n * writer.dispose();\n * ```\n */\nclass StreamWriter {\n    /**\n     * Gets the content written to the StreamWriter as Blob.\n     * @returns Blob\n     */\n    get buffer() {\n        this.flush();\n        return this.bufferBlob;\n    }\n    /**\n     * Gets the encoding.\n     * @returns Encoding\n     */\n    get encoding() {\n        return this.enc;\n    }\n    /**\n     * Initializes a new instance of the StreamWriter class by using the specified encoding.\n     * @param  {Encoding} encoding?- The character encoding to use.\n     */\n    constructor(encoding) {\n        this.bufferBlob = new Blob(['']);\n        this.bufferText = '';\n        this.init(encoding);\n        Save.isMicrosoftBrowser = !(!navigator.msSaveBlob);\n    }\n    init(encoding) {\n        if (encoding === null || encoding === undefined) {\n            this.enc = new Encoding(false);\n            this.enc.type = 'Utf8';\n        }\n        else {\n            this.enc = encoding;\n            this.setBomByte();\n        }\n    }\n    /**\n     * Private method to set Byte Order Mark(BOM) value based on EncodingType\n     */\n    setBomByte() {\n        if (this.encoding.includeBom) {\n            switch (this.encoding.type) {\n                case 'Unicode':\n                    let arrayUnicode = new ArrayBuffer(2);\n                    let uint8 = new Uint8Array(arrayUnicode);\n                    uint8[0] = 255;\n                    uint8[1] = 254;\n                    this.bufferBlob = new Blob([arrayUnicode]);\n                    break;\n                case 'Utf8':\n                    let arrayUtf8 = new ArrayBuffer(3);\n                    let utf8 = new Uint8Array(arrayUtf8);\n                    utf8[0] = 239;\n                    utf8[1] = 187;\n                    utf8[2] = 191;\n                    this.bufferBlob = new Blob([arrayUtf8]);\n                    break;\n                default:\n                    this.bufferBlob = new Blob(['']);\n                    break;\n            }\n        }\n    }\n    /**\n     * Saves the file with specified name and sends the file to client browser\n     * @param  {string} fileName - The file name to save\n     * @returns {void}\n     */\n    save(fileName) {\n        if (this.bufferText !== '') {\n            this.flush();\n        }\n        Save.save(fileName, this.buffer);\n    }\n    /**\n     * Writes the specified string.\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written.\n     * @returns {void}\n     */\n    write(value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText += value;\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    }\n    flush() {\n        if (this.bufferText === undefined || this.bufferText === null || this.bufferText.length === 0) {\n            return;\n        }\n        let bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);\n        this.bufferText = '';\n        this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);\n    }\n    /**\n     * Writes the specified string followed by a line terminator\n     * @param  {string} value - The string to write. If value is null or undefined, nothing is written\n     * @returns {void}\n     */\n    writeLine(value) {\n        if (this.encoding === undefined) {\n            throw new Error('Object Disposed Exception: current writer is disposed');\n        }\n        validateNullOrUndefined(value, 'string');\n        this.bufferText = this.bufferText + value + '\\r\\n';\n        if (this.bufferText.length >= 10240) {\n            this.flush();\n        }\n    }\n    /**\n     * Releases the resources used by the StreamWriter\n     * @returns {void}\n     */\n    destroy() {\n        this.bufferBlob = undefined;\n        this.bufferText = undefined;\n        if (this.enc instanceof Encoding) {\n            this.enc.destroy();\n        }\n        this.enc = undefined;\n    }\n}\n\n// export all modules from current location\n// example: export * from './module'\n/**\n * file utils modules\n */\n\nexport { XmlWriter, Namespace, XmlElement, XmlAttribute, StreamWriter, Encoding, validateNullOrUndefined, Save };\n"]},"metadata":{},"sourceType":"module"}